<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Editor - Apresentação Typewriter</title>
    <style>
      :root {
        --color-primary: #212121;
        --color-accent: #f71963;
        --color-bg: #ffffff;
        --color-text-light: #e7e9ee;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "IBM Plex Mono", monospace;
        font-weight: 600;
        background: var(--color-bg);
        min-height: 100vh;
        color: var(--color-primary);
        overflow-x: hidden;
      }

      /* Toolbar */
      .toolbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: #ffffffc7;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 10px;
        padding: 15px 40px;
        z-index: 1000;
        backdrop-filter: blur(6px);
      }

      .toolbar-left {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      .btn {
        background: #212121;
        color: var(--color-bg);
        border: none;
        padding: 10px 20px;
        font-size: 0.9rem;
        font-family: "IBM Plex Mono", monospace;
        font-weight: 600;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn:hover {
        opacity: 0.8;
        transform: translateY(-1px);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn-play {
        background: #212121;
        font-size: 14px;
        padding: 8px 20px;
      }

      .btn-clear {
        background: #dc2626;
        font-size: 14px;
        padding: 8px 20px;
      }

      .btn-clear:hover {
        background: #b91c1c;
        opacity: 1;
      }

      .btn-settings {
        padding: 8px 8px;
        justify-content: center;
        background: transparent;
        border-radius: 5px;
        font-size: 14px;
        color: #212121;
      }

      .btn-settings:hover {
        background: #f0f0f0;
        transform: none;
      }

      .save-status {
        font-size: 0.85rem;
        color: #666;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .save-status svg {
        width: 14px;
        height: 14px;
      }

      .save-status.saved {
        color: var(--color-primary);
      }

      .save-status.saving {
        color: #999;
      }

      .slide-counter {
        font-size: 0.9rem;
        color: var(--color-primary);
        background: #f0f0f0;
        padding: 8px 16px;
        border-radius: 5px;
      }

      /* Settings Panel */
      .settings-panel {
        position: absolute;
        top: 70px;
        right: 40px;
        background: var(--color-bg);
        border: 2px solid var(--color-text-light);
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: none;
        min-width: 280px;
        z-index: 1001;
        color: var(--color-primary);
      }

      .settings-panel.show {
        display: block;
      }

      .settings-option {
        margin-bottom: 15px;
      }

      .settings-option label {
        display: block;
        font-size: 0.85rem;
        margin-bottom: 8px;
        color: #212121;
      }

      .color-input-wrapper {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .color-input-wrapper input[type="color"] {
        width: 50px;
        height: 40px;
        border: none;
        background-color: transparent;
        border-radius: 5px;
        cursor: pointer;
      }

      .color-input-wrapper input[type="text"] {
        flex: 1;
        padding: 8px 12px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.85rem;
        border: 2px solid var(--color-text-light);
        border-radius: 5px;
        text-transform: uppercase;
      }

      .color-input-wrapper input[type="text"]:focus {
        outline: none;
        border-color: #212121;
      }

      .settings-actions {
        margin-top: 20px;
        padding-top: 15px;
        display: flex;
        gap: 10px;
      }

      .settings-actions button {
        flex: 1;
        align-items: center;
        justify-content: center;
        font-size: 0.85rem;
        padding: 8px 16px;
      }

      /* Editor Container */
      .editor-container {
        max-width: 1000px;
        margin: 0 auto;
        padding: 100px 0;
        min-height: 100vh;
      }

      /* Slide Wrapper */
      .slide-wrapper {
        position: relative;
        margin-bottom: 1rem;
        display: flex;
        align-items: flex-start;
        gap: 20px;
      }

      .slide-wrapper:hover .slide {
        background: #f9f9f9;
      }

      .slide-wrapper:hover .slide-controls {
        opacity: 1;
      }

      /* Numeração do Slide */
      .slide-number {
        flex-shrink: 0;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        font-weight: 600;
        color: #999;
        background: #f5f5f5;
        border-radius: 50%;
        user-select: none;
        position: relative;
        top: 22px;
      }

      .slide-wrapper:hover .slide-number {
        color: #212121;
      }

      /* Slide */
      .slide {
        flex: 1;
        font-size: 2.5rem;
        line-height: 1.1;
        color: #212121;
        padding: 20px 80px 20px 20px;
        border-radius: 8px;
        outline: none;
        cursor: text;
        transition: all 0.2s ease;
        min-height: 80px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        position: relative;
      }

      .slide:focus,
      .slide:focus:hover {
        background: #f1f1f1;
      }

      .slide:focus + .slide-controls {
        opacity: 1;
      }

      .slide[contenteditable="true"]:empty:before {
        content: "Digite seu texto aqui";
        color: #bbb;
      }

      /* Controles do Slide */
      .slide-controls {
        position: absolute;
        top: 27px;
        right: 20px;
        display: flex;
        gap: 8px;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
        z-index: 10;
      }

      .slide-wrapper:hover .slide-controls {
        pointer-events: auto;
      }

      .slide-control-btn {
        background: #1c1c1c15;
        border: none;
        border-radius: 4px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .slide-control-btn:hover {
        background: #f0f0f0;
        border-color: #999;
      }

      .slide-control-btn svg {
        width: 16px;
        height: 16px;
        fill: #666;
      }

      .slide-control-btn:hover svg {
        fill: var(--color-primary);
      }

      /* Image Container */
      .slide-images {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        user-select: none;
        pointer-events: auto;
      }

      .slide-image {
        position: relative;
        max-width: 200px;
      }

      .slide-image img {
        max-width: 100%;
        max-height: 150px;
        object-fit: contain;
        border-radius: 6px;
        border: 2px solid #e7e9ee;
      }

      .slide-image-remove {
        position: absolute;
        top: 8px;
        right: 8px;
        background: #212121;
        color: white;
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1.2rem;
        line-height: 1;
        transition: all 0.2s ease;
      }

      .slide-image-remove:hover {
        opacity: 0.8;
        transform: scale(1.1);
      }

      /* Modal para adicionar imagem */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2000;
        align-items: center;
        justify-content: center;
      }

      .modal.show {
        display: flex;
      }

      .modal-content {
        background: white;
        padding: 30px;
        border-radius: 10px;
        max-width: 500px;
        width: 90%;
        color: #212121;
      }

      .modal-title {
        font-size: 1.5rem;
        margin-bottom: 20px;
        color: #212121;
      }

      .modal-options {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-bottom: 20px;
      }

      .modal-option {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .modal-option input[type="radio"] {
        width: 20px;
        height: 20px;
      }

      .modal-option label {
        font-size: 1rem;
        cursor: pointer;
        color: #212121 !important;
      }

      .modal-input {
        width: 100%;
        padding: 12px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.9rem;
        border: 2px solid #ddd;
        border-radius: 5px;
        margin-top: 10px;
      }

      .modal-input:focus {
        outline: none;
        border-color: var(--color-accent);
      }

      .modal-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 20px;
      }

      .btn-cancel {
        background: var(--color-text-light);
        color: #212121;
      }

      .btn-cancel:hover {
        background: #d0d2d7;
      }

      /* Empty State */
      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: #999;
      }

      .empty-state h2 {
        font-size: 2rem;
        margin-bottom: 10px;
      }

      .empty-state p {
        font-size: 1rem;
        font-weight: 400;
      }

      /* Responsivo */
      @media (max-width: 768px) {
        .toolbar {
          padding: 0 20px;
          height: auto;
          min-height: 60px;
          flex-wrap: wrap;
          gap: 10px;
        }

        .editor-container {
          padding: 100px 20px 100px;
        }

        .slide-wrapper {
          gap: 10px;
        }

        .slide-number {
          width: 32px;
          height: 32px;
          font-size: 1rem;
        }

        .slide {
          font-size: 1.8rem;
          padding: 15px;
        }

        .btn {
          padding: 8px 16px;
          font-size: 0.85rem;
        }

        .btn-play {
          padding: 10px 20px;
          font-size: 0.9rem;
        }

        .slide-image {
          max-width: 150px;
        }

        .slide-image img {
          max-height: 120px;
        }
      }

      @media (max-width: 480px) {
        .slide {
          font-size: 1.5rem;
        }

        .slide-number {
          width: 28px;
          height: 28px;
          font-size: 0.9rem;
        }

        .slide-counter {
          order: -1;
          width: 100%;
          text-align: center;
        }
      }

      /* ================================
         MODO APRESENTAÇÃO (TYPEWRITER FULLSCREEN)
         ================================ */

      .hidden {
        display: none !important;
      }

      /* Container de apresentação */
      .presentation-mode {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--color-bg);
        z-index: 10000;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      .presentation-container {
        width: 90%;
        max-width: 1000px;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding: 0;
        overflow: hidden;
        position: relative;
      }

      #presentation-text-container {
        font-size: 2.5rem;
        line-height: 1.1;
        width: 100%;
        text-align: left;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transition: transform 0.6s ease;
      }

      .text-line {
        margin-bottom: 2rem;
        transition: opacity 0.6s ease;
        width: 100%;
        padding: 0 80px;
        opacity: 1;
      }

      .text-line.completed {
        color: var(--color-text-light);
      }

      .text-line.current {
        opacity: 1;
      }

      .cursor {
        display: inline-block;
        width: 4px;
        height: 2.5rem;
        background-color: var(--color-accent);
        margin-left: 7px;
        animation: blink 0.7s infinite;
        vertical-align: text-bottom;
        position: relative;
        top: -5px;
      }

      .cursor.inactive {
        background-color: var(--color-text-light);
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      /* Container para imagem na apresentação */
      #presentation-image-container {
        position: fixed;
        right: 70px;
        bottom: 52%;
        transform: translateY(50%);
        max-width: 570px;
        opacity: 0;
        pointer-events: none;
        transition: none;
      }

      #presentation-image-container.show {
        opacity: 1;
      }

      #presentation-image-container.animate-first {
        transition: opacity 0.6s ease;
      }

      #presentation-image-container img {
        max-width: 100%;
        max-height: 200px;
        object-fit: contain;
      }

      /* Botão Editar */
      .edit-button {
        position: fixed;
        top: 15px;
        right: 40px;
        background: transparent;
        color: var(--color-primary);
        border: none;
        padding: 8px 20px;
        border-radius: 8px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 10001;
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: "IBM Plex Mono", monospace;
        font-weight: 600;
        font-size: 14px;
      }

      .edit-button svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      .edit-button.visible {
        opacity: 1;
      }

      .edit-button:hover {
        opacity: 0.8 !important;
      }

      /* Responsivo para apresentação */
      @media (max-width: 768px) {
        #presentation-text-container {
          font-size: 1.8rem;
        }

        .cursor {
          height: 1.8rem;
        }

        .text-line {
          padding: 0 20px;
          margin-top: 2rem;
        }

        #presentation-image-container {
          right: 20px;
          max-width: 200px;
          max-height: 250px;
        }

        #presentation-image-container img {
          max-height: 250px;
        }

        .edit-button {
          top: 10px;
          right: 10px;
          padding: 8px 16px;
          font-size: 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Toolbar -->
    <div class="toolbar">
      <button class="btn btn-settings" id="settingsBtn" title="Configurações">
        Editar cores
      </button>
      <button
        class="btn btn-clear"
        id="clearAllBtn"
        title="Deletar todos os slides"
      >
        Limpar tudo
      </button>
      <button class="btn btn-play" id="playBtn">Play</button>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
      <div class="settings-option">
        <label>Cor Principal (texto/highlight)</label>
        <div class="color-input-wrapper">
          <input type="color" id="primaryColorPicker" value="#212121" />
          <input
            type="text"
            id="primaryColorText"
            value="#212121"
            maxlength="7"
            placeholder="#000000"
          />
        </div>
      </div>

      <div class="settings-option">
        <label>Cor Accent (destaque)</label>
        <div class="color-input-wrapper">
          <input type="color" id="accentColorPicker" value="#f71963" />
          <input
            type="text"
            id="accentColorText"
            value="#f71963"
            maxlength="7"
            placeholder="#000000"
          />
        </div>
      </div>

      <div class="settings-actions">
        <button class="btn btn-cancel" id="resetColorsBtn">Resetar</button>
        <button class="btn" id="applyColorsBtn">Aplicar</button>
      </div>
    </div>

    <!-- Editor Container -->
    <div class="editor-container" id="editorContainer">
      <!-- Slides serão adicionados aqui -->
    </div>

    <!-- Modo Apresentação (typewriter fullscreen) -->
    <div id="presentationMode" class="presentation-mode hidden">
      <div class="presentation-container">
        <div id="presentation-text-container">
          <!-- As linhas de texto aparecerão aqui dinamicamente -->
        </div>

        <!-- Container para exibir imagem -->
        <div id="presentation-image-container">
          <img id="presentation-current-image" src="" alt="" />
        </div>
      </div>

      <!-- Botão Editar (aparece no hover) -->
      <button id="editButton" class="edit-button">Editar</button>
    </div>

    <!-- Modal de Adicionar Imagem -->
    <div class="modal" id="imageModal">
      <div class="modal-content">
        <h2 class="modal-title">Adicionar Imagem</h2>

        <div class="modal-options">
          <div class="modal-option">
            <input
              type="radio"
              id="uploadOption"
              name="imageOption"
              value="upload"
              checked
            />
            <label for="uploadOption">Upload de arquivo</label>
          </div>
          <div class="modal-option">
            <input type="radio" id="urlOption" name="imageOption" value="url" />
            <label for="urlOption">URL externa</label>
          </div>
        </div>

        <input
          type="file"
          id="imageUpload"
          accept="image/*"
          class="modal-input"
          style="display: block"
        />
        <input
          type="text"
          id="imageUrl"
          placeholder="https://exemplo.com/imagem.png"
          class="modal-input"
          style="display: none"
        />

        <div class="modal-actions">
          <button class="btn btn-cancel" id="cancelImageBtn">Cancelar</button>
          <button class="btn" id="confirmImageBtn">Adicionar</button>
        </div>
      </div>
    </div>

    <script>
      // Estado da aplicação
      let slides = [];
      let currentFocusedSlide = null;
      let saveTimeout = null;
      let deleteEmptySlideTimeout = null; // Timeout para deletar slides vazios
      let isCreatingNewSlide = false; // Flag para controlar criação de novo slide
      let colors = {
        primary: "#212121",
        accent: "#f71963",
      };

      // Estado da aplicação e modo apresentação
      let currentMode = "edit"; // 'edit' ou 'presentation'
      let hideButtonTimeout = null;

      // Rastreamento de movimento do mouse para botão Editar
      let lastMouseX = null;
      let lastMouseY = null;
      let totalMouseMovement = 0;
      const MOUSE_MOVEMENT_THRESHOLD = 600; // pixels necessários para mostrar botão
      let mouseStopTimeout = null; // Detectar quando mouse realmente parou

      // Estado do typewriter (modo apresentação)
      let currentLineIndex = 0;
      let maxLineShown = 0;
      let isTyping = false;
      let waitingForStart = true;
      let currentImageIndex = 0;
      let typingSpeed = 50;
      let currentTypingTimeout = null;
      let normalizedSlides = [];

      // Elementos DOM
      const editorContainer = document.getElementById("editorContainer");
      const saveStatus = document.getElementById("saveStatus");
      const saveText = document.getElementById("saveText");
      const currentSlideEl = document.getElementById("currentSlide");
      const totalSlidesEl = document.getElementById("totalSlides");
      const playBtn = document.getElementById("playBtn");
      const settingsBtn = document.getElementById("settingsBtn");
      const clearAllBtn = document.getElementById("clearAllBtn");
      const settingsPanel = document.getElementById("settingsPanel");
      const primaryColorPicker = document.getElementById("primaryColorPicker");
      const primaryColorText = document.getElementById("primaryColorText");
      const accentColorPicker = document.getElementById("accentColorPicker");
      const accentColorText = document.getElementById("accentColorText");
      const resetColorsBtn = document.getElementById("resetColorsBtn");
      const applyColorsBtn = document.getElementById("applyColorsBtn");
      const imageModal = document.getElementById("imageModal");
      const uploadOption = document.getElementById("uploadOption");
      const urlOption = document.getElementById("urlOption");
      const imageUpload = document.getElementById("imageUpload");
      const imageUrl = document.getElementById("imageUrl");
      const cancelImageBtn = document.getElementById("cancelImageBtn");
      const confirmImageBtn = document.getElementById("confirmImageBtn");

      // Inicializar
      function init() {
        loadFromLocalStorage();
        loadColors();

        if (slides.length === 0) {
          // Primeira vez usando - criar slides de exemplo
          addSlide("Esse é o Typewriter Slides", []);
          addSlide(
            "Um editor de apresentações com efeito de máquina de escrever",
            [],
          );
          addSlide("Clique em 'Play' para ver esta apresentação em ação", []);
          addSlide("Use Tab para navegar entre slides", []);
          addSlide("Pressione Enter para criar um novo slide", []);
          addSlide("Delete todo o texto para remover um slide", []);
          addSlide("Você pode adicionar imagens clicando no ícone ao lado", []);
          addSlide("Personalize as cores no botão de configurações", []);
          addSlide("Seus slides são salvos automaticamente no navegador", []);

          renderSlides();
        } else {
          // Renderizar slides salvos
          renderSlides();
        }

        updateSlideCounter();

        // Garantir numeração após inicialização
        setTimeout(() => {
          updateSlideNumbers();
        }, 100);

        // Event listeners
        playBtn.addEventListener("click", () => toggleMode("presentation"));
        settingsBtn.addEventListener("click", toggleSettings);
        clearAllBtn.addEventListener("click", clearAllSlides);
        cancelImageBtn.addEventListener("click", closeImageModal);
        confirmImageBtn.addEventListener("click", addImageToSlide);

        // Color picker listeners
        primaryColorPicker.addEventListener("input", (e) => {
          primaryColorText.value = e.target.value;
        });

        primaryColorText.addEventListener("input", (e) => {
          const value = e.target.value;
          if (/^#[0-9A-F]{6}$/i.test(value)) {
            primaryColorPicker.value = value;
          }
        });

        accentColorPicker.addEventListener("input", (e) => {
          accentColorText.value = e.target.value;
        });

        accentColorText.addEventListener("input", (e) => {
          const value = e.target.value;
          if (/^#[0-9A-F]{6}$/i.test(value)) {
            accentColorPicker.value = value;
          }
        });

        applyColorsBtn.addEventListener("click", applyColors);
        resetColorsBtn.addEventListener("click", resetColors);

        // Edit button (modo apresentação)
        const editButton = document.getElementById("editButton");
        editButton.addEventListener("click", () => toggleMode("edit"));

        // Tecla 'E' para toggle do botão Editar
        document.addEventListener("keydown", (e) => {
          if (
            currentMode === "presentation" &&
            e.key.toLowerCase() === "e" &&
            !e.ctrlKey &&
            !e.metaKey &&
            !e.altKey
          ) {
            e.preventDefault();
            editButton.classList.toggle("visible");
          }
        });

        // Mostrar botão Editar no hover (no modo apresentação) - requer movimento significativo
        document.addEventListener("mousemove", (e) => {
          if (currentMode === "presentation") {
            // Se é o primeiro movimento, apenas guardar posição
            if (lastMouseX === null || lastMouseY === null) {
              lastMouseX = e.clientX;
              lastMouseY = e.clientY;
              return;
            }

            // Calcular distância movida desde a última posição
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Acumular movimento total
            totalMouseMovement += distance;

            // Atualizar posição
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            // Só mostrar botão se movimento acumulado for maior que o threshold
            if (totalMouseMovement >= MOUSE_MOVEMENT_THRESHOLD) {
              editButton.classList.add("visible");

              // Limpar timeout anterior de detecção de parada
              clearTimeout(mouseStopTimeout);

              // Detectar quando mouse realmente parou (100ms sem movimento)
              mouseStopTimeout = setTimeout(() => {
                editButton.classList.remove("visible");
                // Resetar contador de movimento quando botão desaparece
                totalMouseMovement = 0;
              }, 1000);
            }
          }
        });

        // Modal options
        uploadOption.addEventListener("change", () => {
          imageUpload.style.display = "block";
          imageUrl.style.display = "none";
        });

        urlOption.addEventListener("change", () => {
          imageUpload.style.display = "none";
          imageUrl.style.display = "block";
        });

        // Fechar modal/settings ao clicar fora
        imageModal.addEventListener("click", (e) => {
          if (e.target === imageModal) {
            closeImageModal();
          }
        });

        document.addEventListener("click", (e) => {
          if (
            !settingsPanel.contains(e.target) &&
            !settingsBtn.contains(e.target)
          ) {
            settingsPanel.classList.remove("show");
          }
        });
      }

      // Criar elemento de slide
      function createSlideElement(text, images, id, slideIndex) {
        // Wrapper do slide
        const wrapper = document.createElement("div");
        wrapper.className = "slide-wrapper";
        wrapper.dataset.id = id;

        // Numeração do slide - calcular baseado no índice passado
        const slideNumber = document.createElement("div");
        slideNumber.className = "slide-number";
        slideNumber.textContent =
          slideIndex !== undefined ? slideIndex + 1 : "1";

        // Slide editável
        const slideDiv = document.createElement("div");
        slideDiv.className = "slide";
        slideDiv.contentEditable = "true";
        slideDiv.setAttribute("tabindex", "0");
        slideDiv.textContent = text;

        // Imagens (dentro do slide, abaixo do texto)
        if (images && images.length > 0) {
          const imagesContainer = document.createElement("div");
          imagesContainer.className = "slide-images";
          imagesContainer.contentEditable = "false";

          images.forEach((imgSrc, index) => {
            const imgWrapper = createImageElement(imgSrc, id, index);
            imagesContainer.appendChild(imgWrapper);
          });

          slideDiv.appendChild(imagesContainer);
        }

        // Controles do slide
        const controls = document.createElement("div");
        controls.className = "slide-controls";

        const imageBtn = document.createElement("button");
        imageBtn.className = "slide-control-btn";
        imageBtn.innerHTML =
          '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
        imageBtn.title = "Adicionar imagem";
        imageBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          openImageModal(wrapper);
        });

        controls.appendChild(imageBtn);

        // Adicionar elementos ao wrapper
        wrapper.appendChild(slideNumber);
        wrapper.appendChild(slideDiv);
        wrapper.appendChild(controls);

        // Event listeners no slide editável
        slideDiv.addEventListener("focus", () =>
          handleSlideFocus(wrapper, slideDiv),
        );
        slideDiv.addEventListener("blur", () =>
          handleSlideBlur(wrapper, slideDiv),
        );
        slideDiv.addEventListener("input", () =>
          handleSlideInput(wrapper, slideDiv),
        );
        slideDiv.addEventListener("keydown", (e) =>
          handleSlideKeydown(e, wrapper, slideDiv),
        );

        return wrapper;
      }

      // Criar elemento de imagem
      function createImageElement(src, slideId, imageIndex) {
        const wrapper = document.createElement("div");
        wrapper.className = "slide-image";

        const img = document.createElement("img");
        img.src = src;
        img.alt = "Slide image";

        const removeBtn = document.createElement("button");
        removeBtn.className = "slide-image-remove";
        removeBtn.innerHTML = "×";
        removeBtn.addEventListener("click", () =>
          removeImage(slideId, imageIndex),
        );

        wrapper.appendChild(img);
        wrapper.appendChild(removeBtn);

        return wrapper;
      }

      // Adicionar novo slide
      function addSlide(text = "", images = [], index = null) {
        const id = generateId();
        const slide = {
          id,
          text,
          images: images || [],
        };

        const slideIndex = index !== null ? index : slides.length;

        if (index === null) {
          slides.push(slide);
        } else {
          slides.splice(index, 0, slide);
        }

        // Criar elemento com o índice correto
        const slideElement = createSlideElement(text, images, id, slideIndex);

        if (index === null) {
          editorContainer.appendChild(slideElement);
        } else {
          const refElement = editorContainer.children[index];
          editorContainer.insertBefore(slideElement, refElement);
        }

        // Atualizar contador
        if (totalSlidesEl) {
          totalSlidesEl.textContent = slides.length;
        }

        // Atualizar TODOS os números (não só o novo)
        updateSlideNumbers();

        scheduleAutoSave();

        return slideElement;
      }

      // Deletar slide
      function deleteSlide(id) {
        const slideIndex = slides.findIndex((s) => s.id === id);
        if (slideIndex === -1) return;

        // Não permitir deletar se for o único slide
        if (slides.length === 1) {
          alert("Você precisa ter pelo menos um slide!");
          return;
        }

        slides.splice(slideIndex, 1);

        const wrapper = document.querySelector(`[data-id="${id}"]`);
        if (wrapper) {
          const nextWrapper = wrapper.nextElementSibling;
          const prevWrapper = wrapper.previousElementSibling;

          wrapper.remove();

          // Focar no próximo ou anterior
          if (nextWrapper) {
            const nextSlideElement = nextWrapper.querySelector(".slide");
            if (nextSlideElement) nextSlideElement.focus();
          } else if (prevWrapper) {
            const prevSlideElement = prevWrapper.querySelector(".slide");
            if (prevSlideElement) prevSlideElement.focus();
          }
        }

        // Atualizar contador
        if (totalSlidesEl) {
          totalSlidesEl.textContent = slides.length;
        }

        // Atualizar numeração imediatamente
        updateSlideNumbers();

        scheduleAutoSave();
      }

      // Limpar todos os slides
      function clearAllSlides() {
        const confirmDelete = confirm(
          "Tem certeza que deseja deletar TODOS os slides? Esta ação não pode ser desfeita.",
        );

        if (!confirmDelete) return;

        // Limpar array de slides
        slides = [];

        // Limpar container
        editorContainer.innerHTML = "";

        // Criar apenas um slide vazio para começar
        addSlide("", []);

        // Focar no slide vazio
        setTimeout(() => {
          const firstSlide = editorContainer.querySelector(".slide");
          if (firstSlide) {
            firstSlide.focus();
          }
        }, 100);

        // Salvar
        scheduleAutoSave();
      }

      // Renderizar todos os slides
      function renderSlides() {
        editorContainer.innerHTML = "";
        slides.forEach((slide, index) => {
          const slideElement = createSlideElement(
            slide.text,
            slide.images,
            slide.id,
            index,
          );
          editorContainer.appendChild(slideElement);
        });

        // Atualizar numeração após renderizar
        updateSlideNumbers();
      }

      // Função auxiliar para extrair apenas o texto do slide (excluindo imagens)
      function getSlideText(slideElement) {
        // Clonar o elemento para não modificar o original
        const clone = slideElement.cloneNode(true);
        // Remover o container de imagens do clone
        const imagesContainer = clone.querySelector(".slide-images");
        if (imagesContainer) {
          imagesContainer.remove();
        }
        return clone.textContent.trim();
      }

      // Focus no slide
      function handleSlideFocus(wrapper, slideElement) {
        // Não fazer nada se estamos criando um novo slide
        if (isCreatingNewSlide) return;

        currentFocusedSlide = wrapper;
        const index = Array.from(editorContainer.children).indexOf(wrapper);
        if (currentSlideEl) {
          currentSlideEl.textContent = index + 1;
        }
      }

      // Blur do slide
      function handleSlideBlur(wrapper, slideElement) {
        // Não fazer nada se estamos criando um novo slide
        if (isCreatingNewSlide) return;

        // Salvar conteúdo
        const id = wrapper.dataset.id;
        const slideIndex = slides.findIndex((s) => s.id === id);
        if (slideIndex !== -1) {
          slides[slideIndex].text = getSlideText(slideElement);
        }
        scheduleAutoSave();
      }

      // Input no slide
      function handleSlideInput(wrapper, slideElement) {
        // Não fazer nada se estamos criando um novo slide
        if (isCreatingNewSlide) return;

        // Limpar timeout anterior
        clearTimeout(deleteEmptySlideTimeout);

        // Verificar se o conteúdo está vazio e deletar automaticamente
        const content = getSlideText(slideElement);

        if (content === "" && slides.length > 1) {
          // Slide vazio e não é o único - deletar após delay (debounce)
          deleteEmptySlideTimeout = setTimeout(() => {
            // Verificar novamente se ainda está vazio
            if (getSlideText(slideElement) === "" && slides.length > 1) {
              const id = wrapper.dataset.id;
              deleteSlide(id);
            }
          }, 800); // Delay de 800ms para dar tempo do usuário colar texto ou continuar digitando
        }

        scheduleAutoSave();
      }

      // Keydown no slide
      function handleSlideKeydown(e, wrapper, slideElement) {
        // Tab: navegar entre slides
        if (e.key === "Tab") {
          e.preventDefault();

          const allWrappers = Array.from(
            document.querySelectorAll(".slide-wrapper"),
          );
          const currentIndex = allWrappers.indexOf(wrapper);

          if (e.shiftKey) {
            // Shift+Tab: voltar para slide anterior
            if (currentIndex > 0) {
              const prevWrapper = allWrappers[currentIndex - 1];
              const prevSlide = prevWrapper.querySelector(".slide");
              if (prevSlide) {
                prevSlide.focus();
                // Posicionar cursor no final
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(prevSlide);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
              }
            }
          } else {
            // Tab: avançar para próximo slide
            if (currentIndex < allWrappers.length - 1) {
              const nextWrapper = allWrappers[currentIndex + 1];
              const nextSlide = nextWrapper.querySelector(".slide");
              if (nextSlide) {
                nextSlide.focus();
                // Posicionar cursor no início
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(nextSlide);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
              }
            }
          }
          return;
        }

        // Enter: criar novo slide
        if (e.key === "Enter") {
          e.preventDefault();

          const id = wrapper.dataset.id;
          const slideIndex = slides.findIndex((s) => s.id === id);

          // Salvar conteúdo atual
          slides[slideIndex].text = getSlideText(slideElement);

          // Criar novo slide
          const newWrapper = addSlide("", [], slideIndex + 1);
          const newSlideElement = newWrapper.querySelector(".slide");

          if (newSlideElement) {
            // Garantir que elemento pode receber foco
            newSlideElement.setAttribute("contentEditable", "true");
            newSlideElement.setAttribute("tabindex", "0");

            // Abordagem recursiva - múltiplas tentativas até conseguir
            const focusNewSlide = () => {
              newSlideElement.focus();

              if (document.activeElement === newSlideElement) {
                // Sucesso! Posicionar cursor
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(newSlideElement);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);

                // Scroll suave
                newWrapper.scrollIntoView({
                  behavior: "smooth",
                  block: "center",
                });
              } else {
                // Falhou, tentar novamente
                setTimeout(focusNewSlide, 50);
              }
            };

            // Iniciar tentativas após pequeno delay
            setTimeout(focusNewSlide, 0);
          }
        }

        // Backspace: deletar slide vazio
        if (e.key === "Backspace" && slideElement.textContent.trim() === "") {
          e.preventDefault();

          const id = wrapper.dataset.id;
          const slideIndex = slides.findIndex((s) => s.id === id);

          // Não deletar se for o único slide
          if (slides.length === 1) {
            return;
          }

          // Focar no slide anterior
          const prevWrapper = wrapper.previousElementSibling;
          if (prevWrapper) {
            deleteSlide(id);

            const prevSlideElement = prevWrapper.querySelector(".slide");
            if (prevSlideElement) {
              prevSlideElement.focus();

              // Mover cursor para o final
              const range = document.createRange();
              const sel = window.getSelection();
              range.selectNodeContents(prevSlideElement);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        }
      }

      // Abrir modal de imagem
      function openImageModal(wrapper) {
        currentFocusedSlide = wrapper;
        imageModal.classList.add("show");
        imageUpload.value = "";
        imageUrl.value = "";
        uploadOption.checked = true;
        imageUpload.style.display = "block";
        imageUrl.style.display = "none";
      }

      // Fechar modal de imagem
      function closeImageModal() {
        imageModal.classList.remove("show");
      }

      // Adicionar imagem ao slide
      function addImageToSlide() {
        if (!currentFocusedSlide) return;

        const id = currentFocusedSlide.dataset.id;
        const slideIndex = slides.findIndex((s) => s.id === id);
        if (slideIndex === -1) return;

        if (uploadOption.checked) {
          // Upload de arquivo
          const file = imageUpload.files[0];
          if (!file) {
            alert("Selecione um arquivo!");
            return;
          }

          const reader = new FileReader();
          reader.onload = function (e) {
            const imgSrc = e.target.result;
            slides[slideIndex].images.push(imgSrc);

            // Adicionar imagem ao DOM (dentro do slide)
            const slideDiv = currentFocusedSlide.querySelector(".slide");
            let imagesContainer = slideDiv.querySelector(".slide-images");
            if (!imagesContainer) {
              imagesContainer = document.createElement("div");
              imagesContainer.className = "slide-images";
              imagesContainer.contentEditable = "false";
              slideDiv.appendChild(imagesContainer);
            }

            const imgWrapper = createImageElement(
              imgSrc,
              id,
              slides[slideIndex].images.length - 1,
            );
            imagesContainer.appendChild(imgWrapper);

            closeImageModal();
            scheduleAutoSave();
          };
          reader.readAsDataURL(file);
        } else {
          // URL externa
          const url = imageUrl.value.trim();
          if (!url) {
            alert("Digite uma URL!");
            return;
          }

          slides[slideIndex].images.push(url);

          // Adicionar imagem ao DOM (dentro do slide)
          const slideDiv = currentFocusedSlide.querySelector(".slide");
          let imagesContainer = slideDiv.querySelector(".slide-images");
          if (!imagesContainer) {
            imagesContainer = document.createElement("div");
            imagesContainer.className = "slide-images";
            imagesContainer.contentEditable = "false";
            slideDiv.appendChild(imagesContainer);
          }

          const imgWrapper = createImageElement(
            url,
            id,
            slides[slideIndex].images.length - 1,
          );
          imagesContainer.appendChild(imgWrapper);

          closeImageModal();
          scheduleAutoSave();
        }
      }

      // Remover imagem
      function removeImage(slideId, imageIndex) {
        const slideIndex = slides.findIndex((s) => s.id === slideId);
        if (slideIndex === -1) return;

        slides[slideIndex].images.splice(imageIndex, 1);

        // Reenderizar imagens (no wrapper)
        const wrapper = document.querySelector(`[data-id="${slideId}"]`);
        if (wrapper) {
          const imagesContainer = wrapper.querySelector(".slide-images");
          if (imagesContainer) {
            if (slides[slideIndex].images.length === 0) {
              imagesContainer.remove();
            } else {
              imagesContainer.innerHTML = "";
              slides[slideIndex].images.forEach((imgSrc, index) => {
                const imgWrapper = createImageElement(imgSrc, slideId, index);
                imagesContainer.appendChild(imgWrapper);
              });
            }
          }
        }

        scheduleAutoSave();
      }

      // Atualizar contador de slides
      function updateSlideCounter() {
        if (totalSlidesEl) {
          totalSlidesEl.textContent = slides.length;
        }
        updateSlideNumbers();
      }

      // Atualizar numeração dos slides
      function updateSlideNumbers() {
        const wrappers = editorContainer.querySelectorAll(".slide-wrapper");
        wrappers.forEach((wrapper, index) => {
          const numberEl = wrapper.querySelector(".slide-number");
          if (numberEl) {
            numberEl.textContent = index + 1;
          }
        });
      }

      // Auto-save com debounce
      function scheduleAutoSave() {
        clearTimeout(saveTimeout);

        if (saveStatus) {
          saveStatus.classList.remove("saved");
          saveStatus.classList.add("saving");
        }
        if (saveText) {
          saveText.textContent = "Salvando...";
        }

        saveTimeout = setTimeout(() => {
          saveToLocalStorage();
          if (saveStatus) {
            saveStatus.classList.remove("saving");
            saveStatus.classList.add("saved");
          }
          if (saveText) {
            saveText.textContent = "Salvo";
          }
        }, 1000);
      }

      // Salvar no localStorage
      function saveToLocalStorage() {
        const data = {
          slides,
          colors,
          lastEdited: new Date().toISOString(),
        };
        localStorage.setItem("typewriter-presentation", JSON.stringify(data));
      }

      // Carregar do localStorage
      function loadFromLocalStorage() {
        const saved = localStorage.getItem("typewriter-presentation");
        if (saved) {
          try {
            const data = JSON.parse(saved);
            slides = data.slides || [];
            if (data.colors) {
              colors = data.colors;
            }
          } catch (e) {
            console.error("Erro ao carregar dados:", e);
            slides = [];
          }
        }
      }

      // Carregar cores
      function loadColors() {
        document.documentElement.style.setProperty(
          "--color-primary",
          colors.primary,
        );
        document.documentElement.style.setProperty(
          "--color-accent",
          colors.accent,
        );
        primaryColorPicker.value = colors.primary;
        primaryColorText.value = colors.primary;
        accentColorPicker.value = colors.accent;
        accentColorText.value = colors.accent;
      }

      // Toggle settings panel
      function toggleSettings() {
        settingsPanel.classList.toggle("show");
      }

      // Aplicar cores
      function applyColors() {
        colors.primary = primaryColorPicker.value;
        colors.accent = accentColorPicker.value;

        document.documentElement.style.setProperty(
          "--color-primary",
          colors.primary,
        );
        document.documentElement.style.setProperty(
          "--color-accent",
          colors.accent,
        );

        saveToLocalStorage();
        settingsPanel.classList.remove("show");
      }

      // Resetar cores
      function resetColors() {
        colors.primary = "#142032";
        colors.accent = "#f71963";

        primaryColorPicker.value = colors.primary;
        primaryColorText.value = colors.primary;
        accentColorPicker.value = colors.accent;
        accentColorText.value = colors.accent;

        document.documentElement.style.setProperty(
          "--color-primary",
          colors.primary,
        );
        document.documentElement.style.setProperty(
          "--color-accent",
          colors.accent,
        );

        saveToLocalStorage();
      }

      // ================================
      // FUNÇÕES DO MODO APRESENTAÇÃO (TYPEWRITER)
      // ================================

      // Normalizar slides do editor para formato apresentação
      function normalizeSlidesForPresentation() {
        return slides.map((slide) => {
          if (typeof slide === "string") {
            return { text: slide, images: null };
          }
          // Converter imagens do editor
          if (slide.images && Array.isArray(slide.images)) {
            return { text: slide.text || "", images: slide.images };
          }
          return { text: slide.text || "", images: null };
        });
      }

      // Esconder imagem
      function hideImage() {
        const imageContainer = document.getElementById(
          "presentation-image-container",
        );
        if (imageContainer) {
          imageContainer.classList.remove("show");
          imageContainer.classList.remove("animate-first");
        }
        currentImageIndex = 0;
      }

      // Mostrar a imagem atual da sequência
      function showCurrentImage() {
        const imageContainer = document.getElementById(
          "presentation-image-container",
        );
        const currentImage = document.getElementById(
          "presentation-current-image",
        );
        const currentSlide = normalizedSlides[currentLineIndex];

        if (
          currentSlide &&
          currentSlide.images &&
          currentSlide.images.length > 0
        ) {
          if (currentImageIndex < currentSlide.images.length) {
            // Animação apenas para a primeira imagem
            if (currentImageIndex === 0) {
              imageContainer.classList.add("animate-first");
              currentImage.src = currentSlide.images[currentImageIndex];
              imageContainer.classList.add("show");
            } else {
              // Imagens seguintes: troca instantânea
              imageContainer.classList.remove("animate-first");
              currentImage.src = currentSlide.images[currentImageIndex];
              imageContainer.classList.add("show");
            }
            return true;
          }
        }
        return false;
      }

      // Avançar para próxima imagem da sequência
      function nextImage() {
        const currentSlide = normalizedSlides[currentLineIndex];
        if (
          currentSlide &&
          currentSlide.images &&
          currentSlide.images.length > 0
        ) {
          if (currentImageIndex < currentSlide.images.length - 1) {
            currentImageIndex++;
            showCurrentImage();
            return true;
          }
        }
        return false;
      }

      // Verificar se há mais imagens na sequência
      function hasMoreImages() {
        const currentSlide = normalizedSlides[currentLineIndex];
        if (
          currentSlide &&
          currentSlide.images &&
          currentSlide.images.length > 0
        ) {
          return currentImageIndex < currentSlide.images.length - 1;
        }
        return false;
      }

      // Atualizar foco para uma linha específica
      function updateFocus() {
        const container = document.getElementById(
          "presentation-text-container",
        );
        const allLines = container.querySelectorAll(".text-line");

        allLines.forEach((line, index) => {
          line.classList.remove("current");
          if (index !== currentLineIndex) {
            line.classList.add("completed");
            const cursor = line.querySelector(".cursor");
            if (cursor) {
              cursor.remove();
            }
          } else {
            line.classList.remove("completed");
            if (!line.querySelector(".cursor")) {
              line.innerHTML += '<span class="cursor inactive"></span>';
            }
          }
        });

        const currentLine = document.getElementById(`line-${currentLineIndex}`);
        if (currentLine) {
          currentLine.classList.add("current");
        }

        waitingForStart = false;
        isTyping = false;

        setTimeout(() => {
          adjustContainerPosition();
        }, 100);

        // Mostrar primeira imagem quando navegar para frase já digitada
        currentImageIndex = 0;
        showCurrentImage();
      }

      // Criar nova linha
      function createNewLine() {
        if (currentLineIndex >= normalizedSlides.length) {
          return;
        }

        const container = document.getElementById(
          "presentation-text-container",
        );

        const allLines = container.querySelectorAll(".text-line");
        allLines.forEach((line, index) => {
          line.classList.remove("current");
          line.classList.add("completed");

          const cursor = line.querySelector(".cursor");
          if (cursor) {
            cursor.remove();
          }
        });

        const lineDiv = document.createElement("div");
        lineDiv.className = "text-line current";
        lineDiv.id = `line-${currentLineIndex}`;
        lineDiv.innerHTML = '<span class="cursor"></span>';
        container.appendChild(lineDiv);

        if (currentLineIndex > maxLineShown) {
          maxLineShown = currentLineIndex;
        }

        setTimeout(() => {
          adjustContainerPosition();
        }, 100);

        waitingForStart = true;
        isTyping = false;

        // Esconder imagem ao criar nova linha
        hideImage();
      }

      // Ajustar posição - manter linha atual centralizada
      function adjustContainerPosition() {
        const container = document.getElementById(
          "presentation-text-container",
        );
        const currentLine = document.getElementById(`line-${currentLineIndex}`);

        if (!currentLine) return;

        // Remover margin-top de todas as linhas
        const allLines = container.querySelectorAll(".text-line");
        allLines.forEach((line) => {
          line.style.marginTop = "0";
        });

        // Calcular o offset necessário
        let offset = 0;
        for (let i = 0; i < currentLineIndex; i++) {
          const line = document.getElementById(`line-${i}`);
          if (line) {
            offset += line.offsetHeight;
            const style = window.getComputedStyle(line);
            offset += parseFloat(style.marginBottom) || 0;
          }
        }

        // Adicionar metade da altura da linha atual
        offset += currentLine.offsetHeight / 2;

        // Aplicar margin-top negativo na primeira linha para deslocar tudo
        const firstLine = container.querySelector(".text-line");
        if (firstLine) {
          firstLine.style.marginTop = `-${offset}px`;
        }
      }

      // Efeito de máquina de escrever
      function typeWriter(text, elementId, charIndex = 0) {
        if (charIndex === 0) {
          isTyping = true;
          document.getElementById(elementId).innerHTML = "";
        }

        if (charIndex < text.length) {
          const currentText = text.substring(0, charIndex + 1);
          document.getElementById(elementId).innerHTML =
            currentText.replace(/\n/g, "<br>") + '<span class="cursor"></span>';

          currentTypingTimeout = setTimeout(() => {
            typeWriter(text, elementId, charIndex + 1);
          }, typingSpeed);
        } else {
          isTyping = false;
          waitingForStart = false;
          document.getElementById(elementId).innerHTML =
            text.replace(/\n/g, "<br>") +
            '<span class="cursor inactive"></span>';

          document.getElementById(elementId).classList.remove("current");

          // Reajustar posição após o texto completo ser renderizado
          setTimeout(() => {
            adjustContainerPosition();
          }, 100);

          // Mostrar primeira imagem da sequência (se houver)
          currentImageIndex = 0;
          showCurrentImage();
        }
      }

      // Iniciar digitação
      function startTyping() {
        if (
          waitingForStart &&
          !isTyping &&
          currentLineIndex < normalizedSlides.length
        ) {
          waitingForStart = false;
          typeWriter(
            normalizedSlides[currentLineIndex].text,
            `line-${currentLineIndex}`,
          );
        }
      }

      // Avançar slide na apresentação
      function nextSlideInPresentation() {
        if (waitingForStart) {
          startTyping();
        } else if (!isTyping) {
          // Verificar se há mais imagens na sequência atual
          if (hasMoreImages()) {
            nextImage();
            return;
          }

          // Se não há mais imagens, avançar para próximo slide
          const nextLineExists = document.getElementById(
            `line-${currentLineIndex + 1}`,
          );

          if (nextLineExists) {
            currentLineIndex++;
            updateFocus();
          } else if (currentLineIndex < normalizedSlides.length - 1) {
            currentLineIndex++;
            setTimeout(() => {
              createNewLine();
            }, 100);
          }
        }
      }

      // Voltar slide
      function previousSlideInPresentation() {
        if (currentLineIndex === 0) {
          return;
        }

        if (isTyping) {
          return;
        }

        if (waitingForStart) {
          const currentLine = document.getElementById(
            `line-${currentLineIndex}`,
          );
          if (currentLine) {
            currentLine.remove();
          }
          if (currentLineIndex === maxLineShown) {
            maxLineShown = Math.max(0, maxLineShown - 1);
          }
        }

        currentLineIndex--;
        updateFocus();
      }

      // Pular animação
      function skipAnimation() {
        if (isTyping && currentLineIndex < normalizedSlides.length) {
          clearTimeout(currentTypingTimeout);
          const textElement = document.getElementById(
            `line-${currentLineIndex}`,
          );

          textElement.innerHTML =
            normalizedSlides[currentLineIndex].text.replace(/\n/g, "<br>") +
            '<span class="cursor inactive"></span>';
          textElement.classList.remove("current");

          isTyping = false;
          waitingForStart = false;

          // Mostrar primeira imagem
          currentImageIndex = 0;
          showCurrentImage();
        }
      }

      // Inicializar apresentação
      function initPresentation() {
        // Normalizar slides
        normalizedSlides = normalizeSlidesForPresentation();

        // Resetar estado
        currentLineIndex = 0;
        maxLineShown = 0;
        isTyping = false;
        waitingForStart = true;
        currentImageIndex = 0;

        // Resetar rastreamento de movimento do mouse
        lastMouseX = null;
        lastMouseY = null;
        totalMouseMovement = 0;
        clearTimeout(mouseStopTimeout);

        // Limpar container de texto
        const textContainer = document.getElementById(
          "presentation-text-container",
        );
        textContainer.innerHTML = "";

        // Mostrar modo apresentação
        document.getElementById("presentationMode").classList.remove("hidden");

        // Criar primeira linha
        createNewLine();

        // Adicionar event listener de teclado
        document.addEventListener("keydown", handlePresentationKeyPress);
      }

      // Resetar apresentação
      function resetPresentation() {
        // Limpar timeout se houver
        if (currentTypingTimeout) {
          clearTimeout(currentTypingTimeout);
        }

        // Limpar container
        const textContainer = document.getElementById(
          "presentation-text-container",
        );
        if (textContainer) {
          textContainer.innerHTML = "";
        }

        // Esconder imagem
        hideImage();

        // Esconder modo apresentação
        document.getElementById("presentationMode").classList.add("hidden");

        // Remover event listener
        document.removeEventListener("keydown", handlePresentationKeyPress);

        // Resetar estado
        currentLineIndex = 0;
        maxLineShown = 0;
        isTyping = false;
        waitingForStart = true;
        currentImageIndex = 0;
        normalizedSlides = [];

        // Resetar rastreamento de movimento do mouse
        lastMouseX = null;
        lastMouseY = null;
        totalMouseMovement = 0;
        clearTimeout(mouseStopTimeout);
      }

      // Reiniciar apresentação do início
      function restartPresentation() {
        // Limpar timeout se houver
        if (currentTypingTimeout) {
          clearTimeout(currentTypingTimeout);
        }

        // Resetar estado
        currentLineIndex = 0;
        maxLineShown = 0;
        isTyping = false;
        waitingForStart = true;
        currentImageIndex = 0;

        // Resetar rastreamento de movimento do mouse
        lastMouseX = null;
        lastMouseY = null;
        totalMouseMovement = 0;
        clearTimeout(mouseStopTimeout);

        // Limpar container de texto
        const textContainer = document.getElementById(
          "presentation-text-container",
        );
        textContainer.innerHTML = "";

        // Esconder imagem
        hideImage();

        // Criar primeira linha novamente
        createNewLine();
      }

      // Navegação por teclado na apresentação
      function handlePresentationKeyPress(e) {
        if (e.key === "ArrowRight" || e.key === "ArrowDown") {
          e.preventDefault();
          nextSlideInPresentation();
        } else if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
          e.preventDefault();
          previousSlideInPresentation();
        } else if (e.key === " ") {
          e.preventDefault();
          if (waitingForStart) {
            startTyping();
          } else {
            skipAnimation();
          }
        } else if (e.key === "r" || e.key === "R") {
          e.preventDefault();
          restartPresentation();
        }
      }

      // Toggle entre modos
      function toggleMode(mode) {
        currentMode = mode;

        if (mode === "presentation") {
          // Salvar antes de apresentar
          saveToLocalStorage();

          // Inicializar apresentação
          initPresentation();
        } else {
          // Resetar estado da apresentação
          resetPresentation();
        }
      }

      // Play apresentação (mantida para compatibilidade, mas não usada mais)
      function playPresentation() {
        toggleMode("presentation");
      }

      // Gerar ID único
      function generateId() {
        return (
          "slide-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9)
        );
      }

      // Inicializar ao carregar
      window.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
