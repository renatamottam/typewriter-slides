<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Editor - Apresentação Typewriter</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <!-- Toolbar -->
    <div class="toolbar">
      <div class="toolbar-left">
        <div class="save-status" id="saveStatus">
          <span id="saveText">Salvo</span>
        </div>
      </div>
      <div class="toolbar-right">
        <button class="btn btn-settings" id="settingsBtn" title="Configurações">
          Configurar
        </button>
        <button
          class="btn btn-clear"
          id="clearAllBtn"
          title="Deletar todos os slides"
        >
          Limpar tudo
        </button>
        <button class="btn btn-play" id="playBtn">Play</button>
      </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
      <div class="settings-option">
        <label>Cor Principal (texto/highlight)</label>
        <div class="color-input-wrapper">
          <input type="color" id="primaryColorPicker" value="#212121" />
          <input
            type="text"
            id="primaryColorText"
            value="#212121"
            maxlength="7"
            placeholder="#000000"
          />
        </div>
      </div>

      <div class="settings-option">
        <label>Cor Accent (destaque)</label>
        <div class="color-input-wrapper">
          <input type="color" id="accentColorPicker" value="#f71963" />
          <input
            type="text"
            id="accentColorText"
            value="#f71963"
            maxlength="7"
            placeholder="#000000"
          />
        </div>
      </div>

      <div class="settings-option">
        <label>Modo de animação typewriter</label>
        <select id="typewriterModeSelect" class="settings-select">
          <option value="auto">Automático (palavras p/ textos grandes)</option>
          <option value="char">Sempre caractere por caractere</option>
          <option value="word">Sempre palavra por palavra</option>
        </select>
      </div>

      <div class="settings-option" id="thresholdOption">
        <label>Limite de caracteres para palavras</label>
        <input
          type="number"
          id="charThresholdInput"
          class="settings-input"
          value="100"
          min="20"
          max="500"
          step="10"
        />
      </div>

      <div class="settings-option" id="initialWordsOption">
        <label>Palavras iniciais letra por letra</label>
        <input
          type="number"
          id="initialWordsInput"
          class="settings-input"
          value="3"
          min="0"
          max="10"
          step="1"
        />
        <small
          style="
            color: #666;
            font-size: 0.75rem;
            margin-top: 4px;
            display: block;
          "
          >Quantas palavras animar letra por letra no início</small
        >
      </div>

      <div class="settings-option">
        <label>Modo de edição</label>
        <select id="editorModeSelect" class="settings-select">
          <option value="slides">Slides individuais</option>
          <option value="markdown">
            Markdown (parágrafos vazios = novo slide)
          </option>
        </select>
      </div>

      <div class="settings-actions">
        <button class="btn btn-cancel" id="resetColorsBtn">Resetar</button>
        <button class="btn" id="applyColorsBtn">Aplicar</button>
      </div>
    </div>

    <!-- Editor Container -->
    <div class="editor-container" id="editorContainer">
      <!-- Slides serão adicionados aqui -->
    </div>

    <!-- Markdown Editor Container -->
    <div class="markdown-container hidden" id="markdownContainer">
      <textarea
        id="markdownEditor"
        class="markdown-editor"
        placeholder="Digite seus slides aqui. Use dois Enter para separar slides.

Exemplo:
Primeiro slide

Segundo slide

Terceiro slide"
      ></textarea>

      <!-- Área para gerenciar imagens no modo markdown -->
      <div class="markdown-images-panel">
        <h3>Imagens Associadas</h3>
        <p style="color: #666; font-size: 0.75rem; line-height: 1.4; margin-bottom: 10px;">
          As imagens são preservadas ao trocar entre modos. Para adicionar ou editar imagens, volte ao modo "Slides individuais".
        </p>
        <div id="markdownImagesContainer"></div>
      </div>
    </div>

    <!-- Modo Apresentação (typewriter fullscreen) -->
    <div id="presentationMode" class="presentation-mode hidden">
      <div class="presentation-container">
        <div id="presentation-text-container">
          <!-- As linhas de texto aparecerão aqui dinamicamente -->
        </div>

        <!-- Container para exibir imagem -->
        <div id="presentation-image-container">
          <img id="presentation-current-image" src="" alt="" />
        </div>
      </div>

      <!-- Botão Editar (aparece no hover) -->
      <button id="editButton" class="edit-button">Editar</button>
    </div>

    <!-- Modal de Adicionar Imagem -->
    <div class="modal" id="imageModal">
      <div class="modal-content">
        <h2 class="modal-title">Adicionar Imagens</h2>

        <div class="modal-options">
          <div class="modal-option">
            <input
              type="radio"
              id="uploadOption"
              name="imageOption"
              value="upload"
              checked
            />
            <label for="uploadOption">Upload de arquivos (múltiplos)</label>
          </div>
          <div class="modal-option">
            <input type="radio" id="urlOption" name="imageOption" value="url" />
            <label for="urlOption">URL externa</label>
          </div>
        </div>

        <input
          type="file"
          id="imageUpload"
          accept="image/*"
          multiple
          class="modal-input"
          style="display: block"
        />
        <input
          type="text"
          id="imageUrl"
          placeholder="https://exemplo.com/imagem.png"
          class="modal-input"
          style="display: none"
        />

        <div class="modal-actions">
          <button class="btn btn-cancel" id="cancelImageBtn">Cancelar</button>
          <button class="btn" id="confirmImageBtn">Adicionar</button>
        </div>
      </div>
    </div>

    <script>
      // Estado da aplicação
      let slides = [];
      let currentFocusedSlide = null;
      let saveTimeout = null;
      let deleteTimeouts = {}; // Timeouts para deletar slides vazios (por ID)
      let isCreatingNewSlide = false; // Flag para controlar criação de novo slide
      let colors = {
        primary: "#212121",
        accent: "#f71963",
      };
      let typewriterSettings = {
        charThreshold: 100, // Caracteres para mudar para modo palavra
        mode: "auto", // 'auto', 'char', 'word'
        initialWords: 3, // Número de palavras iniciais a animar letra por letra
      };
      let editorMode = "slides"; // 'slides' ou 'markdown'
      let markdownContent = ""; // Conteúdo do editor markdown
      let savedImagesMap = {}; // Mapear imagens por texto do slide para preservar ao trocar de modo

      // Estado da aplicação e modo apresentação
      let currentMode = "edit"; // 'edit' ou 'presentation'
      let hideButtonTimeout = null;

      // Rastreamento de movimento do mouse para botão Editar
      let lastMouseX = null;
      let lastMouseY = null;
      let totalMouseMovement = 0;
      const MOUSE_MOVEMENT_THRESHOLD = 600; // pixels necessários para mostrar botão
      let mouseStopTimeout = null; // Detectar quando mouse realmente parou

      // Estado do typewriter (modo apresentação)
      let currentLineIndex = 0;
      let maxLineShown = 0;
      let isTyping = false;
      let waitingForStart = true;
      let currentImageIndex = 0;
      let typingSpeed = 50;
      let currentTypingTimeout = null;
      let normalizedSlides = [];

      // Elementos DOM
      const editorContainer = document.getElementById("editorContainer");
      const saveStatus = document.getElementById("saveStatus");
      const saveText = document.getElementById("saveText");
      const currentSlideEl = document.getElementById("currentSlide");
      const totalSlidesEl = document.getElementById("totalSlides");
      const playBtn = document.getElementById("playBtn");
      const settingsBtn = document.getElementById("settingsBtn");
      const clearAllBtn = document.getElementById("clearAllBtn");
      const settingsPanel = document.getElementById("settingsPanel");
      const primaryColorPicker = document.getElementById("primaryColorPicker");
      const primaryColorText = document.getElementById("primaryColorText");
      const accentColorPicker = document.getElementById("accentColorPicker");
      const accentColorText = document.getElementById("accentColorText");
      const resetColorsBtn = document.getElementById("resetColorsBtn");
      const applyColorsBtn = document.getElementById("applyColorsBtn");
      const imageModal = document.getElementById("imageModal");
      const uploadOption = document.getElementById("uploadOption");
      const urlOption = document.getElementById("urlOption");
      const imageUpload = document.getElementById("imageUpload");
      const imageUrl = document.getElementById("imageUrl");
      const cancelImageBtn = document.getElementById("cancelImageBtn");
      const confirmImageBtn = document.getElementById("confirmImageBtn");
      const typewriterModeSelect = document.getElementById(
        "typewriterModeSelect",
      );
      const charThresholdInput = document.getElementById("charThresholdInput");
      const thresholdOption = document.getElementById("thresholdOption");
      const initialWordsInput = document.getElementById("initialWordsInput");
      const initialWordsOption = document.getElementById("initialWordsOption");
      const editorModeSelect = document.getElementById("editorModeSelect");
      const markdownContainer = document.getElementById("markdownContainer");
      const markdownEditor = document.getElementById("markdownEditor");

      // Inicializar
      function init() {
        loadFromLocalStorage();
        loadColors();
        loadTypewriterSettings();
        loadEditorMode();

        if (slides.length === 0) {
          // Primeira vez usando - criar slides de exemplo
          addSlide("Esse é o Typewriter Slides", []);
          addSlide(
            "Um editor de apresentações com efeito de máquina de escrever",
            [],
          );
          addSlide("Clique em 'Play' para ver esta apresentação em ação", []);
          addSlide("Pressione Enter ou Tab para criar um novo slide", []);
          addSlide("Use Shift+Enter para quebrar linha no mesmo slide", []);
          addSlide("Slides vazios são deletados automaticamente após 0.5s", []);
          addSlide(
            "Você pode adicionar múltiplas imagens clicando no ícone ao lado",
            [],
          );
          addSlide("Personalize as cores no botão de configurações", []);
          addSlide("Seus slides são salvos automaticamente no navegador", []);

          renderSlides();
        } else {
          // Renderizar slides salvos
          renderSlides();
        }

        updateSlideCounter();

        // Garantir numeração após inicialização
        setTimeout(() => {
          updateSlideNumbers();
        }, 100);

        // Event listeners
        playBtn.addEventListener("click", () => toggleMode("presentation"));
        settingsBtn.addEventListener("click", toggleSettings);
        clearAllBtn.addEventListener("click", clearAllSlides);
        cancelImageBtn.addEventListener("click", closeImageModal);
        confirmImageBtn.addEventListener("click", addImageToSlide);

        // Color picker listeners
        primaryColorPicker.addEventListener("input", (e) => {
          primaryColorText.value = e.target.value;
        });

        primaryColorText.addEventListener("input", (e) => {
          const value = e.target.value;
          if (/^#[0-9A-F]{6}$/i.test(value)) {
            primaryColorPicker.value = value;
          }
        });

        accentColorPicker.addEventListener("input", (e) => {
          accentColorText.value = e.target.value;
        });

        accentColorText.addEventListener("input", (e) => {
          const value = e.target.value;
          if (/^#[0-9A-F]{6}$/i.test(value)) {
            accentColorPicker.value = value;
          }
        });

        applyColorsBtn.addEventListener("click", applyColors);
        resetColorsBtn.addEventListener("click", resetColors);

        // Typewriter mode listeners
        typewriterModeSelect.addEventListener("change", (e) => {
          if (e.target.value === "auto") {
            thresholdOption.style.display = "block";
            initialWordsOption.style.display = "block";
          } else if (e.target.value === "word") {
            thresholdOption.style.display = "none";
            initialWordsOption.style.display = "block";
          } else {
            thresholdOption.style.display = "none";
            initialWordsOption.style.display = "none";
          }
        });

        // Editor mode listeners
        editorModeSelect.addEventListener("change", (e) => {
          toggleEditorMode(e.target.value);
          settingsPanel.classList.remove("show");
        });

        // Auto-save no markdown editor
        markdownEditor.addEventListener("input", () => {
          markdownContent = markdownEditor.value;
          
          // Verificar se há slides com imagens que não correspondem mais ao texto
          checkOrphanedImages();
          
          scheduleAutoSave();
        });

        // Função para verificar imagens órfãs (quando o texto do slide foi modificado)
        function checkOrphanedImages() {
          if (editorMode !== "markdown") return;
          
          const currentParagraphs = markdownEditor.value
            .split(/\n\n+/)
            .filter((p) => p.trim() !== "")
            .map((p) => p.trim());
          
          const savedTexts = Object.keys(savedImagesMap);
          let hasOrphans = false;
          
          savedTexts.forEach((savedText) => {
            if (!currentParagraphs.includes(savedText)) {
              hasOrphans = true;
            }
          });
          
          // Se houver imagens órfãs, podemos adicionar um aviso visual (opcional)
          // Por enquanto, as imagens serão mantidas no mapa até serem explicitamente removidas
        }

        // Edit button (modo apresentação)
        const editButton = document.getElementById("editButton");
        editButton.addEventListener("click", () => toggleMode("edit"));

        // Tecla 'E' para toggle do botão Editar
        document.addEventListener("keydown", (e) => {
          if (
            currentMode === "presentation" &&
            e.key.toLowerCase() === "e" &&
            !e.ctrlKey &&
            !e.metaKey &&
            !e.altKey
          ) {
            e.preventDefault();
            editButton.classList.toggle("visible");
          }
        });

        // Mostrar botão Editar no hover (no modo apresentação) - requer movimento significativo
        document.addEventListener("mousemove", (e) => {
          if (currentMode === "presentation") {
            // Se é o primeiro movimento, apenas guardar posição
            if (lastMouseX === null || lastMouseY === null) {
              lastMouseX = e.clientX;
              lastMouseY = e.clientY;
              return;
            }

            // Calcular distância movida desde a última posição
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Acumular movimento total
            totalMouseMovement += distance;

            // Atualizar posição
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            // Só mostrar botão se movimento acumulado for maior que o threshold
            if (totalMouseMovement >= MOUSE_MOVEMENT_THRESHOLD) {
              editButton.classList.add("visible");

              // Limpar timeout anterior de detecção de parada
              clearTimeout(mouseStopTimeout);

              // Detectar quando mouse realmente parou (100ms sem movimento)
              mouseStopTimeout = setTimeout(() => {
                editButton.classList.remove("visible");
                // Resetar contador de movimento quando botão desaparece
                totalMouseMovement = 0;
              }, 1000);
            }
          }
        });

        // Modal options
        uploadOption.addEventListener("change", () => {
          imageUpload.style.display = "block";
          imageUrl.style.display = "none";
        });

        urlOption.addEventListener("change", () => {
          imageUpload.style.display = "none";
          imageUrl.style.display = "block";
        });

        // Fechar modal/settings ao clicar fora
        imageModal.addEventListener("click", (e) => {
          if (e.target === imageModal) {
            closeImageModal();
          }
        });

        document.addEventListener("click", (e) => {
          if (
            !settingsPanel.contains(e.target) &&
            !settingsBtn.contains(e.target)
          ) {
            settingsPanel.classList.remove("show");
          }
        });
      }

      // Criar elemento de slide
      function createSlideElement(text, images, id, slideIndex) {
        // Wrapper do slide
        const wrapper = document.createElement("div");
        wrapper.className = "slide-wrapper";
        wrapper.dataset.id = id;

        // Numeração do slide - calcular baseado no índice passado
        const slideNumber = document.createElement("div");
        slideNumber.className = "slide-number";
        slideNumber.textContent =
          slideIndex !== undefined ? slideIndex + 1 : "1";

        // Slide editável
        const slideDiv = document.createElement("div");
        slideDiv.className = "slide";
        slideDiv.contentEditable = "true";
        slideDiv.setAttribute("tabindex", "0");

        // Converter quebras de linha (\n) em <br> para exibição
        slideDiv.innerHTML = text.replace(/\n/g, "<br>");

        // Imagens (dentro do slide, abaixo do texto)
        if (images && images.length > 0) {
          const imagesContainer = document.createElement("div");
          imagesContainer.className = "slide-images";
          imagesContainer.contentEditable = "false";

          images.forEach((imgSrc, index) => {
            const imgWrapper = createImageElement(imgSrc, id, index, images.length);
            imagesContainer.appendChild(imgWrapper);
          });

          slideDiv.appendChild(imagesContainer);
        }

        // Controles do slide
        const controls = document.createElement("div");
        controls.className = "slide-controls";

        const imageBtn = document.createElement("button");
        imageBtn.className = "slide-control-btn";
        imageBtn.innerHTML =
          '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
        imageBtn.title = "Adicionar imagens";
        imageBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          openImageModal(wrapper);
        });

        controls.appendChild(imageBtn);

        // Adicionar elementos ao wrapper
        wrapper.appendChild(slideNumber);
        wrapper.appendChild(slideDiv);
        wrapper.appendChild(controls);

        // Event listeners no slide editável
        slideDiv.addEventListener("focus", () =>
          handleSlideFocus(wrapper, slideDiv),
        );
        slideDiv.addEventListener("blur", () =>
          handleSlideBlur(wrapper, slideDiv),
        );
        slideDiv.addEventListener("input", () =>
          handleSlideInput(wrapper, slideDiv),
        );
        slideDiv.addEventListener("keydown", (e) =>
          handleSlideKeydown(e, wrapper, slideDiv),
        );

        return wrapper;
      }

      // Criar elemento de imagem
      function createImageElement(src, slideId, imageIndex, totalImages) {
        const wrapper = document.createElement("div");
        wrapper.className = "slide-image";
        wrapper.dataset.imageIndex = imageIndex;
        wrapper.dataset.slideId = slideId;

        // Wrapper da imagem e botão
        const imgWrapper = document.createElement("div");
        imgWrapper.className = "slide-image-wrapper";

        const img = document.createElement("img");
        img.src = src;
        img.alt = "Slide image";

        // Botão remover
        const removeBtn = document.createElement("button");
        removeBtn.className = "slide-image-remove";
        removeBtn.innerHTML = "×";
        removeBtn.title = "Remover imagem";
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          removeImage(slideId, imageIndex);
        });

        imgWrapper.appendChild(img);
        imgWrapper.appendChild(removeBtn);

        // Só adicionar drag handle e habilitar drag se houver mais de uma imagem
        if (totalImages > 1) {
          // Indicador de drag (à esquerda)
          const dragHandle = document.createElement("div");
          dragHandle.className = "slide-image-drag-handle";
          dragHandle.innerHTML = "⋮";
          dragHandle.title = "Arrastar para reordenar";
          
          wrapper.draggable = true;
          
          // Event listeners para drag-and-drop
          wrapper.addEventListener("dragstart", handleDragStart);
          wrapper.addEventListener("dragend", handleDragEnd);
          wrapper.addEventListener("dragover", handleDragOver);
          wrapper.addEventListener("drop", handleDrop);
          wrapper.addEventListener("dragenter", handleDragEnter);
          wrapper.addEventListener("dragleave", handleDragLeave);
          
          wrapper.appendChild(dragHandle);
        }
        
        wrapper.appendChild(imgWrapper);

        return wrapper;
      }

      // Adicionar novo slide
      function addSlide(text = "", images = [], index = null) {
        const id = generateId();
        const slide = {
          id,
          text,
          images: images || [],
        };

        const slideIndex = index !== null ? index : slides.length;

        if (index === null) {
          slides.push(slide);
        } else {
          slides.splice(index, 0, slide);
        }

        // Criar elemento com o índice correto
        const slideElement = createSlideElement(text, images, id, slideIndex);

        if (index === null) {
          editorContainer.appendChild(slideElement);
        } else {
          const refElement = editorContainer.children[index];
          editorContainer.insertBefore(slideElement, refElement);
        }

        // Atualizar contador
        if (totalSlidesEl) {
          totalSlidesEl.textContent = slides.length;
        }

        // Atualizar TODOS os números (não só o novo)
        updateSlideNumbers();

        scheduleAutoSave();

        return slideElement;
      }

      // Deletar slide
      function deleteSlide(id) {
        const slideIndex = slides.findIndex((s) => s.id === id);
        if (slideIndex === -1) return;

        // Não permitir deletar se for o único slide
        if (slides.length === 1) {
          alert("Você precisa ter pelo menos um slide!");
          return;
        }

        slides.splice(slideIndex, 1);

        const wrapper = document.querySelector(`[data-id="${id}"]`);
        if (wrapper) {
          // Limpar timeout e classe antes de remover
          if (deleteTimeouts[id]) {
            clearTimeout(deleteTimeouts[id]);
            delete deleteTimeouts[id];
          }
          wrapper.classList.remove("deleting-soon");

          const nextWrapper = wrapper.nextElementSibling;
          const prevWrapper = wrapper.previousElementSibling;

          wrapper.remove();

          // Focar no próximo ou anterior
          if (nextWrapper) {
            const nextSlideElement = nextWrapper.querySelector(".slide");
            if (nextSlideElement) nextSlideElement.focus();
          } else if (prevWrapper) {
            const prevSlideElement = prevWrapper.querySelector(".slide");
            if (prevSlideElement) prevSlideElement.focus();
          }
        }

        // Atualizar contador
        if (totalSlidesEl) {
          totalSlidesEl.textContent = slides.length;
        }

        // Atualizar numeração imediatamente
        updateSlideNumbers();

        scheduleAutoSave();
      }

      // Limpar todos os slides
      function clearAllSlides() {
        const confirmDelete = confirm(
          "Tem certeza que deseja deletar TODOS os slides? Esta ação não pode ser desfeita.",
        );

        if (!confirmDelete) return;

        // Limpar array de slides
        slides = [];

        // Limpar container
        editorContainer.innerHTML = "";

        // Criar apenas um slide vazio para começar
        addSlide("", []);

        // Focar no slide vazio
        setTimeout(() => {
          const firstSlide = editorContainer.querySelector(".slide");
          if (firstSlide) {
            firstSlide.focus();
          }
        }, 100);

        // Salvar
        scheduleAutoSave();
      }

      // Renderizar todos os slides
      function renderSlides() {
        editorContainer.innerHTML = "";
        slides.forEach((slide, index) => {
          const slideElement = createSlideElement(
            slide.text,
            slide.images,
            slide.id,
            index,
          );
          editorContainer.appendChild(slideElement);
        });

        // Atualizar numeração após renderizar
        updateSlideNumbers();
      }

      // Função auxiliar para extrair apenas o texto do slide (excluindo imagens)
      function getSlideText(slideElement) {
        // Clonar o elemento para não modificar o original
        const clone = slideElement.cloneNode(true);
        // Remover o container de imagens do clone
        const imagesContainer = clone.querySelector(".slide-images");
        if (imagesContainer) {
          imagesContainer.remove();
        }

        // Converter <br> e <div> em quebras de linha antes de pegar o texto
        const brs = clone.querySelectorAll("br");
        brs.forEach((br) => {
          br.replaceWith("\n");
        });

        // Tratar divs que o contentEditable cria
        const divs = clone.querySelectorAll("div");
        divs.forEach((div, index) => {
          if (index > 0) {
            div.insertAdjacentText("beforebegin", "\n");
          }
        });

        return clone.textContent.trim();
      }

      // Focus no slide
      function handleSlideFocus(wrapper, slideElement) {
        // Não fazer nada se estamos criando um novo slide
        if (isCreatingNewSlide) return;

        // Cancelar deleção pendente ao focar
        const id = wrapper.dataset.id;
        if (deleteTimeouts[id]) {
          clearTimeout(deleteTimeouts[id]);
          delete deleteTimeouts[id];
        }
        wrapper.classList.remove("deleting-soon");

        currentFocusedSlide = wrapper;
        const index = Array.from(editorContainer.children).indexOf(wrapper);
        if (currentSlideEl) {
          currentSlideEl.textContent = index + 1;
        }
      }

      // Blur do slide
      function handleSlideBlur(wrapper, slideElement) {
        // Não fazer nada se estamos criando um novo slide
        if (isCreatingNewSlide) return;

        // Salvar conteúdo
        const id = wrapper.dataset.id;
        const slideIndex = slides.findIndex((s) => s.id === id);
        if (slideIndex !== -1) {
          slides[slideIndex].text = getSlideText(slideElement);
        }

        // Se o slide ficou vazio após perder o foco, agendar deleção
        const content = getSlideText(slideElement);
        if (content === "" && slides.length > 1) {
          wrapper.classList.add("deleting-soon");
          deleteTimeouts[id] = setTimeout(() => {
            if (getSlideText(slideElement) === "" && slides.length > 1) {
              deleteSlide(id);
            }
          }, 500);
        }

        scheduleAutoSave();
      }

      // Input no slide
      function handleSlideInput(wrapper, slideElement) {
        // Não fazer nada se estamos criando um novo slide
        if (isCreatingNewSlide) return;

        const id = wrapper.dataset.id;

        // Atualizar conteúdo do slide no array ANTES de salvar
        const slideIndex = slides.findIndex((s) => s.id === id);
        if (slideIndex !== -1) {
          slides[slideIndex].text = getSlideText(slideElement);
        }

        // Limpar timeout anterior deste slide
        if (deleteTimeouts[id]) {
          clearTimeout(deleteTimeouts[id]);
          delete deleteTimeouts[id];
        }

        // Remover indicador visual de deleção pendente
        wrapper.classList.remove("deleting-soon");

        // Verificar se o conteúdo está vazio e deletar automaticamente
        const content = getSlideText(slideElement);

        if (content === "" && slides.length > 1) {
          // Adicionar classe visual indicando que será deletado
          wrapper.classList.add("deleting-soon");

          // Slide vazio e não é o único - deletar após delay (debounce)
          deleteTimeouts[id] = setTimeout(() => {
            // Verificar novamente se ainda está vazio
            if (getSlideText(slideElement) === "" && slides.length > 1) {
              deleteSlide(id);
            }
          }, 500); // Delay de 0.5s para dar tempo do usuário digitar ou colar texto
        }

        scheduleAutoSave();
      }

      // Keydown no slide
      function handleSlideKeydown(e, wrapper, slideElement) {
        // Tab: criar novo slide (mesmo comportamento do Enter)
        if (e.key === "Tab") {
          e.preventDefault();

          const id = wrapper.dataset.id;
          const slideIndex = slides.findIndex((s) => s.id === id);

          // Salvar conteúdo atual
          slides[slideIndex].text = getSlideText(slideElement);

          // Criar novo slide
          const newWrapper = addSlide("", [], slideIndex + 1);
          const newSlideElement = newWrapper.querySelector(".slide");

          if (newSlideElement) {
            // Garantir que elemento pode receber foco
            newSlideElement.setAttribute("contentEditable", "true");
            newSlideElement.setAttribute("tabindex", "0");

            // Abordagem recursiva - múltiplas tentativas até conseguir
            const focusNewSlide = () => {
              newSlideElement.focus();

              if (document.activeElement === newSlideElement) {
                // Sucesso! Posicionar cursor
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(newSlideElement);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);

                // Scroll suave
                newWrapper.scrollIntoView({
                  behavior: "smooth",
                  block: "center",
                });
              } else {
                // Falhou, tentar novamente
                setTimeout(focusNewSlide, 50);
              }
            };

            // Iniciar tentativas após pequeno delay
            setTimeout(focusNewSlide, 0);
          }
          return;
        }

        // Enter: criar novo slide ou quebrar linha (com Shift)
        if (e.key === "Enter") {
          if (e.shiftKey) {
            // Shift+Enter: quebrar linha dentro do mesmo slide
            e.preventDefault();
            document.execCommand("insertLineBreak");
            return;
          }

          // Enter sozinho: criar novo slide
          e.preventDefault();

          const id = wrapper.dataset.id;
          const slideIndex = slides.findIndex((s) => s.id === id);

          // Salvar conteúdo atual
          slides[slideIndex].text = getSlideText(slideElement);

          // Criar novo slide
          const newWrapper = addSlide("", [], slideIndex + 1);
          const newSlideElement = newWrapper.querySelector(".slide");

          if (newSlideElement) {
            // Garantir que elemento pode receber foco
            newSlideElement.setAttribute("contentEditable", "true");
            newSlideElement.setAttribute("tabindex", "0");

            // Abordagem recursiva - múltiplas tentativas até conseguir
            const focusNewSlide = () => {
              newSlideElement.focus();

              if (document.activeElement === newSlideElement) {
                // Sucesso! Posicionar cursor
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(newSlideElement);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);

                // Scroll suave
                newWrapper.scrollIntoView({
                  behavior: "smooth",
                  block: "center",
                });
              } else {
                // Falhou, tentar novamente
                setTimeout(focusNewSlide, 50);
              }
            };

            // Iniciar tentativas após pequeno delay
            setTimeout(focusNewSlide, 0);
          }
        }

        // Backspace: deletar slide vazio
        if (e.key === "Backspace" && slideElement.textContent.trim() === "") {
          e.preventDefault();

          const id = wrapper.dataset.id;
          const slideIndex = slides.findIndex((s) => s.id === id);

          // Não deletar se for o único slide
          if (slides.length === 1) {
            return;
          }

          // Focar no slide anterior
          const prevWrapper = wrapper.previousElementSibling;
          if (prevWrapper) {
            deleteSlide(id);

            const prevSlideElement = prevWrapper.querySelector(".slide");
            if (prevSlideElement) {
              prevSlideElement.focus();

              // Mover cursor para o final
              const range = document.createRange();
              const sel = window.getSelection();
              range.selectNodeContents(prevSlideElement);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        }
      }

      // Abrir modal de imagem
      function openImageModal(wrapper) {
        currentFocusedSlide = wrapper;
        imageModal.classList.add("show");
        imageUpload.value = "";
        imageUrl.value = "";
        uploadOption.checked = true;
        imageUpload.style.display = "block";
        imageUrl.style.display = "none";
      }

      // Fechar modal de imagem
      function closeImageModal() {
        imageModal.classList.remove("show");
      }

      // Adicionar imagem ao slide
      function addImageToSlide() {
        if (!currentFocusedSlide) return;

        const id = currentFocusedSlide.dataset.id;
        const slideIndex = slides.findIndex((s) => s.id === id);
        if (slideIndex === -1) return;

        if (uploadOption.checked) {
          // Upload de arquivo(s)
          const files = imageUpload.files;
          if (!files || files.length === 0) {
            alert("Selecione pelo menos um arquivo!");
            return;
          }

          // Preparar container de imagens
          const slideDiv = currentFocusedSlide.querySelector(".slide");
          let imagesContainer = slideDiv.querySelector(".slide-images");
          if (!imagesContainer) {
            imagesContainer = document.createElement("div");
            imagesContainer.className = "slide-images";
            imagesContainer.contentEditable = "false";
            slideDiv.appendChild(imagesContainer);
          }

          let filesProcessed = 0;
          const totalFiles = files.length;

          // Processar cada arquivo
          Array.from(files).forEach((file) => {
            const reader = new FileReader();
            reader.onload = function (e) {
              const imgSrc = e.target.result;
              slides[slideIndex].images.push(imgSrc);

              filesProcessed++;

              // Reenderizar imagens após cada adição
              rerenderImages(id, slideIndex);

              // Fechar modal e salvar apenas quando todos os arquivos forem processados
              if (filesProcessed === totalFiles) {
                closeImageModal();
                scheduleAutoSave();
              }
            };
            reader.readAsDataURL(file);
          });
        } else {
          // URL externa
          const url = imageUrl.value.trim();
          if (!url) {
            alert("Digite uma URL!");
            return;
          }

          slides[slideIndex].images.push(url);

          // Reenderizar imagens
          rerenderImages(id, slideIndex);

          closeImageModal();
          scheduleAutoSave();
        }
      }

      // Remover imagem
      function removeImage(slideId, imageIndex) {
        const slideIndex = slides.findIndex((s) => s.id === slideId);
        if (slideIndex === -1) return;

        slides[slideIndex].images.splice(imageIndex, 1);

        // Reenderizar imagens (no wrapper)
        rerenderImages(slideId, slideIndex);

        scheduleAutoSave();
      }

      // Variáveis para drag-and-drop
      let draggedElement = null;
      let draggedFromIndex = null;
      let draggedSlideId = null;

      // Handlers de drag-and-drop
      function handleDragStart(e) {
        draggedElement = this;
        draggedFromIndex = parseInt(this.dataset.imageIndex);
        draggedSlideId = this.dataset.slideId;
        
        this.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/html", this.innerHTML);
      }

      function handleDragEnd(e) {
        this.classList.remove("dragging");
        
        // Remover classe de todos os elementos
        const allImages = document.querySelectorAll(".slide-image");
        allImages.forEach((img) => {
          img.classList.remove("drag-over");
        });

        draggedElement = null;
        draggedFromIndex = null;
        draggedSlideId = null;
      }

      function handleDragOver(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        e.dataTransfer.dropEffect = "move";
        return false;
      }

      function handleDragEnter(e) {
        if (this !== draggedElement && this.dataset.slideId === draggedSlideId) {
          this.classList.add("drag-over");
        }
      }

      function handleDragLeave(e) {
        this.classList.remove("drag-over");
      }

      function handleDrop(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        }

        const dropSlideId = this.dataset.slideId;
        
        // Só permitir drop dentro do mesmo slide
        if (draggedElement !== this && draggedSlideId === dropSlideId) {
          const toIndex = parseInt(this.dataset.imageIndex);
          moveImage(draggedSlideId, draggedFromIndex, toIndex);
        }

        return false;
      }

      // Mover imagem
      function moveImage(slideId, fromIndex, toIndex) {
        const slideIndex = slides.findIndex((s) => s.id === slideId);
        if (slideIndex === -1) return;

        const images = slides[slideIndex].images;
        if (toIndex < 0 || toIndex >= images.length) return;

        // Mover a imagem
        const [movedImage] = images.splice(fromIndex, 1);
        images.splice(toIndex, 0, movedImage);

        // Reenderizar imagens
        rerenderImages(slideId, slideIndex);

        scheduleAutoSave();
      }

      // Reenderizar imagens de um slide
      function rerenderImages(slideId, slideIndex) {
        const wrapper = document.querySelector(`[data-id="${slideId}"]`);
        if (!wrapper) return;

        const slideDiv = wrapper.querySelector(".slide");
        let imagesContainer = slideDiv.querySelector(".slide-images");

        // Se não há imagens, remover container
        if (slides[slideIndex].images.length === 0) {
          if (imagesContainer) {
            imagesContainer.remove();
          }
          return;
        }

        // Criar container se não existir
        if (!imagesContainer) {
          imagesContainer = document.createElement("div");
          imagesContainer.className = "slide-images";
          imagesContainer.contentEditable = "false";
          slideDiv.appendChild(imagesContainer);
        }

        // Reenderizar todas as imagens
        imagesContainer.innerHTML = "";
        const totalImages = slides[slideIndex].images.length;
        slides[slideIndex].images.forEach((imgSrc, index) => {
          const imgWrapper = createImageElement(imgSrc, slideId, index, totalImages);
          imagesContainer.appendChild(imgWrapper);
        });
      }

      // Atualizar contador de slides
      function updateSlideCounter() {
        if (totalSlidesEl) {
          totalSlidesEl.textContent = slides.length;
        }
        updateSlideNumbers();
      }

      // Atualizar numeração dos slides
      function updateSlideNumbers() {
        const wrappers = editorContainer.querySelectorAll(".slide-wrapper");
        wrappers.forEach((wrapper, index) => {
          const numberEl = wrapper.querySelector(".slide-number");
          if (numberEl) {
            numberEl.textContent = index + 1;
          }
        });
      }

      // Auto-save com debounce
      function scheduleAutoSave() {
        clearTimeout(saveTimeout);

        if (saveStatus) {
          saveStatus.classList.remove("saved");
          saveStatus.classList.add("saving");
        }
        if (saveText) {
          saveText.textContent = "Salvando...";
        }

        saveTimeout = setTimeout(() => {
          saveToLocalStorage();
          if (saveStatus) {
            saveStatus.classList.remove("saving");
            saveStatus.classList.add("saved");
          }
          if (saveText) {
            saveText.textContent = "Salvo";
          }
        }, 300); // Delay de 300ms para salvamento mais responsivo
      }

      // Salvar no localStorage
      function saveToLocalStorage() {
        const data = {
          slides,
          colors,
          typewriterSettings,
          editorMode,
          markdownContent,
          savedImagesMap,
          lastEdited: new Date().toISOString(),
        };
        localStorage.setItem("typewriter-presentation", JSON.stringify(data));
      }

      // Carregar do localStorage
      function loadFromLocalStorage() {
        const saved = localStorage.getItem("typewriter-presentation");
        if (saved) {
          try {
            const data = JSON.parse(saved);
            slides = data.slides || [];
            if (data.colors) {
              colors = data.colors;
            }
            if (data.typewriterSettings) {
              typewriterSettings = data.typewriterSettings;
            }
            if (data.editorMode) {
              editorMode = data.editorMode;
            }
            if (data.markdownContent) {
              markdownContent = data.markdownContent;
            }
            if (data.savedImagesMap) {
              savedImagesMap = data.savedImagesMap;
            }
          } catch (e) {
            console.error("Erro ao carregar dados:", e);
            slides = [];
          }
        }
      }

      // Carregar cores
      function loadColors() {
        document.documentElement.style.setProperty(
          "--color-primary",
          colors.primary,
        );
        document.documentElement.style.setProperty(
          "--color-accent",
          colors.accent,
        );
        primaryColorPicker.value = colors.primary;
        primaryColorText.value = colors.primary;
        accentColorPicker.value = colors.accent;
        accentColorText.value = colors.accent;
      }

      // Carregar configurações de typewriter
      function loadTypewriterSettings() {
        typewriterModeSelect.value = typewriterSettings.mode;
        charThresholdInput.value = typewriterSettings.charThreshold;
        initialWordsInput.value = typewriterSettings.initialWords || 3;

        if (typewriterSettings.mode === "auto") {
          thresholdOption.style.display = "block";
          initialWordsOption.style.display = "block";
        } else if (typewriterSettings.mode === "word") {
          thresholdOption.style.display = "none";
          initialWordsOption.style.display = "block";
        } else {
          thresholdOption.style.display = "none";
          initialWordsOption.style.display = "none";
        }
      }

      // Carregar modo de edição
      function loadEditorMode() {
        editorModeSelect.value = editorMode;

        if (editorMode === "markdown") {
          markdownEditor.value = markdownContent;
          editorContainer.classList.add("hidden");
          markdownContainer.classList.remove("hidden");
        } else {
          markdownContainer.classList.add("hidden");
          editorContainer.classList.remove("hidden");
        }
      }

      // Toggle settings panel
      function toggleSettings() {
        settingsPanel.classList.toggle("show");
      }

      // Aplicar cores
      function applyColors() {
        colors.primary = primaryColorPicker.value;
        colors.accent = accentColorPicker.value;

        document.documentElement.style.setProperty(
          "--color-primary",
          colors.primary,
        );
        document.documentElement.style.setProperty(
          "--color-accent",
          colors.accent,
        );

        // Salvar configurações de typewriter
        typewriterSettings.mode = typewriterModeSelect.value;
        typewriterSettings.charThreshold = parseInt(
          charThresholdInput.value,
          10,
        );
        typewriterSettings.initialWords = parseInt(initialWordsInput.value, 10);

        saveToLocalStorage();
        settingsPanel.classList.remove("show");
      }

      // Resetar cores
      function resetColors() {
        colors.primary = "#142032";
        colors.accent = "#f71963";

        primaryColorPicker.value = colors.primary;
        primaryColorText.value = colors.primary;
        accentColorPicker.value = colors.accent;
        accentColorText.value = colors.accent;

        document.documentElement.style.setProperty(
          "--color-primary",
          colors.primary,
        );
        document.documentElement.style.setProperty(
          "--color-accent",
          colors.accent,
        );

        saveToLocalStorage();
      }

      // ================================
      // FUNÇÕES DO MODO APRESENTAÇÃO (TYPEWRITER)
      // ================================

      // Normalizar slides do editor para formato apresentação
      function normalizeSlidesForPresentation() {
        return slides.map((slide) => {
          if (typeof slide === "string") {
            return { text: slide, images: null };
          }
          // Converter imagens do editor
          if (slide.images && Array.isArray(slide.images)) {
            return { text: slide.text || "", images: slide.images };
          }
          return { text: slide.text || "", images: null };
        });
      }

      // Esconder imagem
      function hideImage() {
        const imageContainer = document.getElementById(
          "presentation-image-container",
        );
        if (imageContainer) {
          imageContainer.classList.remove("show");
          imageContainer.classList.remove("animate-first");
        }
        currentImageIndex = 0;
      }

      // Mostrar a imagem atual da sequência
      function showCurrentImage() {
        const imageContainer = document.getElementById(
          "presentation-image-container",
        );
        const currentImage = document.getElementById(
          "presentation-current-image",
        );
        const currentSlide = normalizedSlides[currentLineIndex];

        if (
          currentSlide &&
          currentSlide.images &&
          currentSlide.images.length > 0
        ) {
          if (currentImageIndex < currentSlide.images.length) {
            // Animação apenas para a primeira imagem
            if (currentImageIndex === 0) {
              imageContainer.classList.add("animate-first");
              currentImage.src = currentSlide.images[currentImageIndex];
              imageContainer.classList.add("show");
            } else {
              // Imagens seguintes: troca instantânea
              imageContainer.classList.remove("animate-first");
              currentImage.src = currentSlide.images[currentImageIndex];
              imageContainer.classList.add("show");
            }
            return true;
          }
        }
        return false;
      }

      // Avançar para próxima imagem da sequência
      function nextImage() {
        const currentSlide = normalizedSlides[currentLineIndex];
        if (
          currentSlide &&
          currentSlide.images &&
          currentSlide.images.length > 0
        ) {
          if (currentImageIndex < currentSlide.images.length - 1) {
            currentImageIndex++;
            showCurrentImage();
            return true;
          }
        }
        return false;
      }

      // Verificar se há mais imagens na sequência
      function hasMoreImages() {
        const currentSlide = normalizedSlides[currentLineIndex];
        if (
          currentSlide &&
          currentSlide.images &&
          currentSlide.images.length > 0
        ) {
          return currentImageIndex < currentSlide.images.length - 1;
        }
        return false;
      }

      // Atualizar foco para uma linha específica
      function updateFocus() {
        const container = document.getElementById(
          "presentation-text-container",
        );
        const allLines = container.querySelectorAll(".text-line");

        allLines.forEach((line, index) => {
          line.classList.remove("current");
          if (index !== currentLineIndex) {
            line.classList.add("completed");
            const cursor = line.querySelector(".cursor");
            if (cursor) {
              cursor.remove();
            }
          } else {
            line.classList.remove("completed");
            if (!line.querySelector(".cursor")) {
              line.innerHTML += '<span class="cursor inactive"></span>';
            }
          }
        });

        const currentLine = document.getElementById(`line-${currentLineIndex}`);
        if (currentLine) {
          currentLine.classList.add("current");
        }

        waitingForStart = false;
        isTyping = false;

        setTimeout(() => {
          adjustContainerPosition();
        }, 100);

        // Mostrar primeira imagem quando navegar para frase já digitada
        currentImageIndex = 0;
        showCurrentImage();
      }

      // Criar nova linha
      function createNewLine() {
        if (currentLineIndex >= normalizedSlides.length) {
          return;
        }

        const container = document.getElementById(
          "presentation-text-container",
        );

        const allLines = container.querySelectorAll(".text-line");
        allLines.forEach((line, index) => {
          line.classList.remove("current");
          line.classList.add("completed");

          const cursor = line.querySelector(".cursor");
          if (cursor) {
            cursor.remove();
          }
        });

        const lineDiv = document.createElement("div");
        lineDiv.className = "text-line current";
        lineDiv.id = `line-${currentLineIndex}`;
        lineDiv.innerHTML = '<span class="cursor"></span>';
        container.appendChild(lineDiv);

        if (currentLineIndex > maxLineShown) {
          maxLineShown = currentLineIndex;
        }

        setTimeout(() => {
          adjustContainerPosition();
        }, 100);

        waitingForStart = true;
        isTyping = false;

        // Esconder imagem ao criar nova linha
        hideImage();
      }

      // Ajustar posição - manter linha atual centralizada
      function adjustContainerPosition() {
        const container = document.getElementById(
          "presentation-text-container",
        );
        const currentLine = document.getElementById(`line-${currentLineIndex}`);

        if (!currentLine) return;

        // Remover margin-top de todas as linhas
        const allLines = container.querySelectorAll(".text-line");
        allLines.forEach((line) => {
          line.style.marginTop = "0";
        });

        // Calcular o offset necessário
        let offset = 0;
        for (let i = 0; i < currentLineIndex; i++) {
          const line = document.getElementById(`line-${i}`);
          if (line) {
            offset += line.offsetHeight;
            const style = window.getComputedStyle(line);
            offset += parseFloat(style.marginBottom) || 0;
          }
        }

        // Adicionar metade da altura da linha atual
        offset += currentLine.offsetHeight / 2;

        // Aplicar margin-top negativo na primeira linha para deslocar tudo
        const firstLine = container.querySelector(".text-line");
        if (firstLine) {
          firstLine.style.marginTop = `-${offset}px`;
        }
      }

      // Determinar modo de digitação baseado no texto e configurações
      function getTypingMode(text) {
        if (typewriterSettings.mode === "char") {
          return "char";
        } else if (typewriterSettings.mode === "word") {
          return "word";
        } else {
          // Modo automático
          return text.length >= typewriterSettings.charThreshold
            ? "word"
            : "char";
        }
      }

      // Dividir texto em palavras, mantendo espaços e quebras de linha
      function splitIntoWords(text) {
        const words = [];
        let currentWord = "";

        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          currentWord += char;

          // Se encontrar espaço ou quebra de linha após uma palavra, adicionar ao array
          if (char === " " || char === "\n" || i === text.length - 1) {
            if (currentWord.trim().length > 0 || currentWord.length > 0) {
              words.push(currentWord);
              currentWord = "";
            }
          }
        }

        return words;
      }

      // Efeito de máquina de escrever (caractere por caractere)
      function typeWriterChar(text, elementId, charIndex = 0) {
        if (charIndex === 0) {
          isTyping = true;
          document.getElementById(elementId).innerHTML = "";
        }

        if (charIndex < text.length) {
          const currentText = text.substring(0, charIndex + 1);
          document.getElementById(elementId).innerHTML =
            currentText.replace(/\n/g, "<br>") + '<span class="cursor"></span>';

          currentTypingTimeout = setTimeout(() => {
            typeWriterChar(text, elementId, charIndex + 1);
          }, typingSpeed);
        } else {
          finishTyping(text, elementId);
        }
      }

      // Efeito de máquina de escrever (palavra por palavra)
      function typeWriterWord(
        text,
        elementId,
        wordIndex = 0,
        words = null,
        charIndexInWord = 0,
      ) {
        if (wordIndex === 0 && charIndexInWord === 0) {
          isTyping = true;
          document.getElementById(elementId).innerHTML = "";
          words = splitIntoWords(text);
        }

        if (!words) {
          words = splitIntoWords(text);
        }

        if (wordIndex < words.length) {
          const initialWords = typewriterSettings.initialWords || 0;

          // Se estamos nas palavras iniciais, animar letra por letra
          if (wordIndex < initialWords) {
            const currentWord = words[wordIndex];

            if (charIndexInWord < currentWord.length) {
              // Animando letra por letra dentro da palavra inicial
              const previousWords = words.slice(0, wordIndex).join("");
              const currentWordPartial = currentWord.substring(
                0,
                charIndexInWord + 1,
              );
              const currentText = previousWords + currentWordPartial;

              document.getElementById(elementId).innerHTML =
                currentText.replace(/\n/g, "<br>") +
                '<span class="cursor"></span>';

              currentTypingTimeout = setTimeout(() => {
                typeWriterWord(
                  text,
                  elementId,
                  wordIndex,
                  words,
                  charIndexInWord + 1,
                );
              }, typingSpeed);
            } else {
              // Palavra completa, passar para próxima
              currentTypingTimeout = setTimeout(() => {
                typeWriterWord(text, elementId, wordIndex + 1, words, 0);
              }, typingSpeed * 2);
            }
          } else {
            // Após palavras iniciais, mostrar palavra completa de uma vez
            const currentText = words.slice(0, wordIndex + 1).join("");
            document.getElementById(elementId).innerHTML =
              currentText.replace(/\n/g, "<br>") +
              '<span class="cursor"></span>';

            currentTypingTimeout = setTimeout(() => {
              typeWriterWord(text, elementId, wordIndex + 1, words, 0);
            }, typingSpeed * 3); // Palavras aparecem mais devagar
          }
        } else {
          finishTyping(text, elementId);
        }
      }

      // Finalizar digitação
      function finishTyping(text, elementId) {
        isTyping = false;
        waitingForStart = false;
        document.getElementById(elementId).innerHTML =
          text.replace(/\n/g, "<br>") + '<span class="cursor inactive"></span>';

        document.getElementById(elementId).classList.remove("current");

        // Reajustar posição após o texto completo ser renderizado
        setTimeout(() => {
          adjustContainerPosition();
        }, 100);

        // Mostrar primeira imagem da sequência (se houver)
        currentImageIndex = 0;
        showCurrentImage();
      }

      // Efeito de máquina de escrever (função principal)
      function typeWriter(text, elementId) {
        const mode = getTypingMode(text);
        if (mode === "word") {
          typeWriterWord(text, elementId, 0);
        } else {
          typeWriterChar(text, elementId, 0);
        }
      }

      // Iniciar digitação
      function startTyping() {
        if (
          waitingForStart &&
          !isTyping &&
          currentLineIndex < normalizedSlides.length
        ) {
          waitingForStart = false;
          typeWriter(
            normalizedSlides[currentLineIndex].text,
            `line-${currentLineIndex}`,
          );
        }
      }

      // Avançar slide na apresentação
      function nextSlideInPresentation() {
        if (waitingForStart) {
          startTyping();
        } else if (!isTyping) {
          // Verificar se há mais imagens na sequência atual
          if (hasMoreImages()) {
            nextImage();
            return;
          }

          // Se não há mais imagens, avançar para próximo slide
          const nextLineExists = document.getElementById(
            `line-${currentLineIndex + 1}`,
          );

          if (nextLineExists) {
            currentLineIndex++;
            updateFocus();
          } else if (currentLineIndex < normalizedSlides.length - 1) {
            currentLineIndex++;
            setTimeout(() => {
              createNewLine();
            }, 100);
          }
        }
      }

      // Voltar slide
      function previousSlideInPresentation() {
        if (currentLineIndex === 0) {
          return;
        }

        if (isTyping) {
          return;
        }

        if (waitingForStart) {
          const currentLine = document.getElementById(
            `line-${currentLineIndex}`,
          );
          if (currentLine) {
            currentLine.remove();
          }
          if (currentLineIndex === maxLineShown) {
            maxLineShown = Math.max(0, maxLineShown - 1);
          }
        }

        currentLineIndex--;
        updateFocus();
      }

      // Pular animação
      function skipAnimation() {
        if (isTyping && currentLineIndex < normalizedSlides.length) {
          clearTimeout(currentTypingTimeout);
          const textElement = document.getElementById(
            `line-${currentLineIndex}`,
          );

          textElement.innerHTML =
            normalizedSlides[currentLineIndex].text.replace(/\n/g, "<br>") +
            '<span class="cursor inactive"></span>';
          textElement.classList.remove("current");

          isTyping = false;
          waitingForStart = false;

          // Mostrar primeira imagem
          currentImageIndex = 0;
          showCurrentImage();
        }
      }

      // Inicializar apresentação
      function initPresentation() {
        // Normalizar slides
        normalizedSlides = normalizeSlidesForPresentation();

        // Resetar estado
        currentLineIndex = 0;
        maxLineShown = 0;
        isTyping = false;
        waitingForStart = true;
        currentImageIndex = 0;

        // Resetar rastreamento de movimento do mouse
        lastMouseX = null;
        lastMouseY = null;
        totalMouseMovement = 0;
        clearTimeout(mouseStopTimeout);

        // Limpar container de texto
        const textContainer = document.getElementById(
          "presentation-text-container",
        );
        textContainer.innerHTML = "";

        // Mostrar modo apresentação
        document.getElementById("presentationMode").classList.remove("hidden");

        // Criar primeira linha
        createNewLine();

        // Adicionar event listener de teclado
        document.addEventListener("keydown", handlePresentationKeyPress);
      }

      // Resetar apresentação
      function resetPresentation() {
        // Limpar timeout se houver
        if (currentTypingTimeout) {
          clearTimeout(currentTypingTimeout);
        }

        // Limpar container
        const textContainer = document.getElementById(
          "presentation-text-container",
        );
        if (textContainer) {
          textContainer.innerHTML = "";
        }

        // Esconder imagem
        hideImage();

        // Esconder modo apresentação
        document.getElementById("presentationMode").classList.add("hidden");

        // Remover event listener
        document.removeEventListener("keydown", handlePresentationKeyPress);

        // Resetar estado
        currentLineIndex = 0;
        maxLineShown = 0;
        isTyping = false;
        waitingForStart = true;
        currentImageIndex = 0;
        normalizedSlides = [];

        // Resetar rastreamento de movimento do mouse
        lastMouseX = null;
        lastMouseY = null;
        totalMouseMovement = 0;
        clearTimeout(mouseStopTimeout);
      }

      // Reiniciar apresentação do início
      function restartPresentation() {
        // Limpar timeout se houver
        if (currentTypingTimeout) {
          clearTimeout(currentTypingTimeout);
        }

        // Resetar estado
        currentLineIndex = 0;
        maxLineShown = 0;
        isTyping = false;
        waitingForStart = true;
        currentImageIndex = 0;

        // Resetar rastreamento de movimento do mouse
        lastMouseX = null;
        lastMouseY = null;
        totalMouseMovement = 0;
        clearTimeout(mouseStopTimeout);

        // Limpar container de texto
        const textContainer = document.getElementById(
          "presentation-text-container",
        );
        textContainer.innerHTML = "";

        // Esconder imagem
        hideImage();

        // Criar primeira linha novamente
        createNewLine();
      }

      // Navegação por teclado na apresentação
      function handlePresentationKeyPress(e) {
        if (e.key === "ArrowRight" || e.key === "ArrowDown") {
          e.preventDefault();
          nextSlideInPresentation();
        } else if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
          e.preventDefault();
          previousSlideInPresentation();
        } else if (e.key === " ") {
          e.preventDefault();
          if (waitingForStart) {
            startTyping();
          } else {
            skipAnimation();
          }
        } else if (e.key === "r" || e.key === "R") {
          e.preventDefault();
          restartPresentation();
        }
      }

      // Toggle entre modos
      function toggleMode(mode) {
        currentMode = mode;

        if (mode === "presentation") {
          // Se estiver em modo markdown, converter para slides primeiro
          if (editorMode === "markdown") {
            slides = markdownToSlides(markdownEditor.value);
          }

          // Salvar antes de apresentar
          saveToLocalStorage();

          // Inicializar apresentação
          initPresentation();
        } else {
          // Resetar estado da apresentação
          resetPresentation();
        }
      }

      // Play apresentação (mantida para compatibilidade, mas não usada mais)
      function playPresentation() {
        toggleMode("presentation");
      }

      // ================================
      // FUNÇÕES DO MODO MARKDOWN
      // ================================

      // Converter slides para markdown
      function slidesToMarkdown() {
        // Salvar imagens mapeadas por texto do slide
        savedImagesMap = {};
        slides.forEach((slide) => {
          if (slide.images && slide.images.length > 0) {
            savedImagesMap[slide.text.trim()] = [...slide.images];
          }
        });
        
        return slides.map((slide) => slide.text).join("\n\n");
      }

      // Converter markdown para slides
      function markdownToSlides(markdownText) {
        // Dividir por parágrafos vazios (duplo \n)
        const paragraphs = markdownText
          .split(/\n\n+/)
          .filter((p) => p.trim() !== "");

        // Criar array de slides restaurando imagens quando possível
        const newSlides = paragraphs.map((text) => {
          const trimmedText = text.trim();
          return {
            id: generateId(),
            text: trimmedText,
            images: savedImagesMap[trimmedText] || [], // Restaurar imagens se existirem
          };
        });

        return newSlides.length > 0
          ? newSlides
          : [{ id: generateId(), text: "", images: [] }];
      }

      // Atualizar painel de imagens no modo markdown
      function updateMarkdownImagesPanel() {
        const container = document.getElementById("markdownImagesContainer");
        container.innerHTML = "";

        if (Object.keys(savedImagesMap).length === 0) {
          container.innerHTML = '<p style="color: #999; font-size: 0.85rem; margin-top: 10px;">Nenhuma imagem associada ainda.</p>';
          return;
        }

        // Info box
        const infoBox = document.createElement("div");
        infoBox.style.marginTop = "10px";
        infoBox.style.padding = "10px";
        infoBox.style.background = "#fff9e6";
        infoBox.style.borderRadius = "6px";
        infoBox.style.border = "1px solid #ffd966";
        infoBox.style.fontSize = "0.75rem";
        infoBox.style.color = "#666";
        infoBox.style.lineHeight = "1.4";
        infoBox.innerHTML = '<strong>💡 Dica:</strong> As imagens são vinculadas ao texto do slide. Se você editar o texto aqui, as imagens serão mantidas quando você voltar ao modo slides.';
        container.appendChild(infoBox);

        Object.entries(savedImagesMap).forEach(([slideText, images]) => {
          if (images && images.length > 0) {
            const slideDiv = document.createElement("div");
            slideDiv.style.marginTop = "15px";
            slideDiv.style.padding = "10px";
            slideDiv.style.background = "white";
            slideDiv.style.borderRadius = "6px";
            slideDiv.style.border = "1px solid #e7e9ee";

            const slideTitle = document.createElement("div");
            slideTitle.style.fontSize = "0.85rem";
            slideTitle.style.fontWeight = "600";
            slideTitle.style.marginBottom = "8px";
            slideTitle.style.color = "#212121";
            slideTitle.textContent = slideText.substring(0, 50) + (slideText.length > 50 ? "..." : "");

            const imagesCount = document.createElement("div");
            imagesCount.style.fontSize = "0.75rem";
            imagesCount.style.color = "#666";
            imagesCount.style.marginBottom = "8px";
            imagesCount.textContent = `${images.length} imagem${images.length > 1 ? "ns" : ""}`;

            // Mostrar miniaturas das imagens
            const thumbsContainer = document.createElement("div");
            thumbsContainer.style.display = "flex";
            thumbsContainer.style.gap = "6px";
            thumbsContainer.style.flexWrap = "wrap";
            thumbsContainer.style.marginTop = "8px";

            images.slice(0, 3).forEach((imgSrc) => {
              const thumb = document.createElement("img");
              thumb.src = imgSrc;
              thumb.style.width = "40px";
              thumb.style.height = "40px";
              thumb.style.objectFit = "cover";
              thumb.style.borderRadius = "4px";
              thumb.style.border = "1px solid #e7e9ee";
              thumbsContainer.appendChild(thumb);
            });

            if (images.length > 3) {
              const more = document.createElement("div");
              more.style.width = "40px";
              more.style.height = "40px";
              more.style.display = "flex";
              more.style.alignItems = "center";
              more.style.justifyContent = "center";
              more.style.borderRadius = "4px";
              more.style.border = "1px solid #e7e9ee";
              more.style.fontSize = "0.75rem";
              more.style.color = "#666";
              more.style.background = "#f5f5f5";
              more.textContent = `+${images.length - 3}`;
              thumbsContainer.appendChild(more);
            }

            slideDiv.appendChild(slideTitle);
            slideDiv.appendChild(imagesCount);
            slideDiv.appendChild(thumbsContainer);
            container.appendChild(slideDiv);
          }
        });
      }

      // Alternar entre modos
      function toggleEditorMode(newMode) {
        if (newMode === editorMode) return;

        if (newMode === "markdown") {
          // Converter slides atuais para markdown
          markdownContent = slidesToMarkdown();
          markdownEditor.value = markdownContent;

          // Atualizar painel de imagens
          updateMarkdownImagesPanel();

          // Trocar visualização
          editorContainer.classList.add("hidden");
          markdownContainer.classList.remove("hidden");
        } else {
          // Converter markdown para slides
          slides = markdownToSlides(markdownEditor.value);
          renderSlides();

          // Trocar visualização
          markdownContainer.classList.add("hidden");
          editorContainer.classList.remove("hidden");
        }

        editorMode = newMode;
        scheduleAutoSave();
      }

      // Gerar ID único
      function generateId() {
        return (
          "slide-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9)
        );
      }

      // Inicializar ao carregar
      window.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
